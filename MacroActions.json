{
  "Actions": [
    {
      "Name": "0. Info\\0. Output object details in a grid",
      "Enabled": "true",
      "Execute": "// This script displays a grid with details about each measure in the model.\r\n\r\n// Source: https://docs.tabulareditor.com/common/CSharpScripts/Advanced/script-output-things.html\r\n\r\nusing System.Data;\r\n\r\nvar result = new DataTable();\r\nresult.Columns.Add(\"Name\");\r\nresult.Columns.Add(\"Table\");\r\nresult.Columns.Add(\"Expression token count\", typeof(int));\r\nresult.Columns.Add(\"Expression line count\", typeof(int));\r\nresult.Columns.Add(\"Description line count\", typeof(int));\r\nresult.Columns.Add(\"Format String\");\r\n\r\nforeach(var m in Model.AllMeasures)\r\n{\r\n    var row = new object[]\r\n    {\r\n        m.DaxObjectName,    // Name\r\n        m.Table.Name,       // Table\r\n        m.Tokenize().Count, // Token count\r\n        m.Expression.Split(new []{'\\n'}, StringSplitOptions.RemoveEmptyEntries).Length,\r\n        m.Description.Split(new []{'\\n'}, StringSplitOptions.RemoveEmptyEntries).Length,\r\n        m.FormatStringExpression ?? m.FormatString\r\n    };\r\n    result.Rows.Add(row);\r\n}\r\n\r\nOutput(result);\r\n",
      "Tooltip": "Show details of each measure in the model",
      "ValidContexts": "Model"
    },
    {
      "Name": "0. Info\\0. Preview selected column(s)",
      "Enabled": "true",
      "Execute": "// Construct the DAX expression to get all distinct column values, from the selected column:\r\nvar dax = string.Format(\"ALL({0})\", Selected.Column.DaxObjectFullName);\r\n\r\n// Evaluate the DAX expression against the connected model:\r\nvar result = EvaluateDax(dax);\r\n\r\n// Output the DataTable containing the result of the DAX expression:\r\nOutput(result);\r\n",
      "Tooltip": "Show details for column",
      "ValidContexts": "Column"
    },
    {
      "Name": "0. Info\\0. Preview selected columns and measures",
      "Enabled": "true",
      "Execute": "\r\n// Source - Data Goblins: https://github.com/data-goblin/powerbi-macguyver-toolbox/blob/main/tabular-editor-scripts/csharp-scripts/preview-selected-objects.csx\r\n\r\n// Instructions\r\n// ------------\r\n// 1. Save this script as a macro with a context of 'Column' and 'Measure'\r\n// 2. Configure a keyboard shortcut for the macro (i.e. ALT + C) if using Tabular Editor 3\r\n// 3. Select any combination of columns & measures related in the model & run the script\r\n// 4. The output will show you the evaluation result for all selected objects, presuming evaluation is valid\r\n\r\n\r\n// Get column names\r\nvar _ColumnsList = new List<string>();\r\nforeach ( var _SelectedColumn in Selected.Columns )\r\n{\r\n    _ColumnsList.Add(_SelectedColumn.DaxObjectFullName);\r\n}\r\nstring _Columns = String.Join(\",\", _ColumnsList );\r\n\r\n\r\n// Get measure names\r\nvar _MeasuresList = new List<string>();\r\nvar _MeasuresOnlyList = new List<string>();\r\nforeach ( var _SelectedMeasure in Selected.Measures )\r\n{\r\n    // Create a syntax for evaluating objects when measures + columns are selected\r\n    _MeasuresList.Add( @\"\"\"@\" + _SelectedMeasure.Name + @\"\"\"\" );\r\n    _MeasuresList.Add(_SelectedMeasure.DaxObjectFullName);\r\n\r\n    // Create a syntax for evaluating objects when only measures are selected\r\n    _MeasuresOnlyList.Add( \r\n        \"\\nADDCOLUMNS (\\n{\" + \r\n        @\"\"\"\" + _SelectedMeasure.Name + @\"\"\"\" + \r\n        \"},\\n\" + \r\n        @\"\"\"\" + \"Result\" + @\"\"\"\" + \r\n        \",\\n\" + \r\n        _SelectedMeasure.DaxObjectFullName + \")\");\r\n}\r\nstring _Measures = String.Join(\",\", _MeasuresList );\r\n\r\n\r\n// Results differ depending on how many columns, measures are selected\r\nint _NrMeasures = Selected.Measures.Count();\r\nint _NrColumns = Selected.Columns.Count();\r\n\r\n\r\n// ----------------------------------------------------------------------------------------------------------//\r\n// Result if a combination of measures and columns are selected\r\nif ( _NrMeasures > 0 && _NrColumns > 0 )\r\n{\r\n    // Summarize selected columns + measures with DAX\r\n    string _dax = \r\n        \"SUMMARIZECOLUMNS ( \" + _Columns + \", \" + _Measures + \")\";\r\n\r\n    // Return output in pop-up\r\n    EvaluateDax(_dax).Output();\r\n}\r\n\r\n\r\n// ----------------------------------------------------------------------------------------------------------//\r\n// Result if no columns selected and more than one measure selected\r\nelse if ( _NrColumns == 0 && _NrMeasures > 1 )\r\n{\r\n    // Evaluate each measure as a separate row\r\n    string _dax = \r\n        \"SELECTCOLUMNS( UNION ( \" +                    // SELECTCOLUMNS to re-name cols, UNION to combine rows\r\n        String.Join(\",\", _MeasuresOnlyList ) + \"),\" +  // Concatenate list of measure evaluations\r\n        @\"\"\"\" + \"Measure Name\" + @\"\"\"\" +               // Re-name first column as \"Measure Name\"\r\n        \", [Value],\" +                                 // \r\n        @\"\"\"\" + \"Measure Result\" + @\"\"\"\" +             // Re-name second column as \"Measure Result\"\r\n        \", [Result])\" ;                                // \r\n\r\n    // Return output in pop-up\r\n    EvaluateDax(_dax).Output();\r\n}\r\n\r\n\r\n// ----------------------------------------------------------------------------------------------------------//\r\n// Result if no columns selected and exactly one measure selected\r\nelse if ( _NrColumns == 0 && _NrMeasures == 1 )\r\n{\r\n    // Evaluate each measure as a separate row\r\n    string _dax =                                      \r\n        \"SELECTCOLUMNS( \" +                           // SELECTCOLUMNS to re-name cols\r\n        String.Join(\",\", _MeasuresOnlyList ) + \",\" +  // Concatenate list of measure evaluations \r\n        @\"\"\"\" + \"Measure Name\" + @\"\"\"\" +              // Re-name first column as \"Measure Name\" \r\n        \", [Value],\" +                                //  \r\n        @\"\"\"\" + \"Measure Result\" + @\"\"\"\" +            // Re-name second column as \"Measure Result\"\r\n        \", [Result])\" ;                               // \r\n    \r\n    // Return output in pop-up\r\n    EvaluateDax(_dax).Output();\r\n}\r\n\r\n\r\n// ----------------------------------------------------------------------------------------------------------//\r\n// Result if no measures and only columns are selected\r\nelse\r\n{\r\n    // Summarize selected columns with DAX\r\n    string _dax = \r\n        \"SUMMARIZECOLUMNS ( \" + _Columns + \")\";\r\n\r\n    // Return output in pop-up\r\n    EvaluateDax(_dax).Output();\r\n}",
      "Tooltip": "Show details for columns and measures",
      "ValidContexts": "Measure, Column"
    },
    {
      "Name": "1. Create Table\\1. Create Calculated Date Table",
      "Enabled": "true",
      "Execute": "// Adapted from https://github.com/data-goblin/powerbi-macguyver-toolbox/blob/main/tabular-editor-scripts/csharp-scripts/import-model-only/create-date-table.csx\r\n// This script works in Tabular Editor 2\r\n\r\n// 1. Select the column with the earliest date\r\n// 2. Select the column with the latest date\r\n// 3. Script generates a calculated table with rich date metadata\r\n\r\nvar _dateColumns = Model.AllColumns.Where(c => c.DataType == DataType.DateTime).ToList();\r\n\r\nstring _EarliestDateInput;\r\ntry\r\n{\r\n    _EarliestDateInput = SelectColumn(_dateColumns, null, \"Select the Column with the Earliest Date:\").DaxObjectFullName;\r\n}\r\ncatch\r\n{\r\n    Error(\"Earliest column not selected! Script stopped.\");\r\n    return;\r\n}\r\n\r\nstring _LatestDateInput;\r\ntry\r\n{\r\n    _LatestDateInput = SelectColumn(_dateColumns, null, \"Select the Column with the Latest Date:\").DaxObjectFullName;\r\n}\r\ncatch\r\n{\r\n    Error(\"Latest column not selected! Script stopped.\");\r\n    return;\r\n}\r\n\r\ntry\r\n{\r\n    string _RefDateMeasureLogic = string.Format(\"CALCULATE ( MAX ( {0} ), REMOVEFILTERS ( ) )\", _LatestDateInput);\r\n\r\n    string _DateDaxExpression = string.Format(@\"\r\nVAR _Today = TODAY ()\r\n\r\nVAR _EarliestDate = DATE ( YEAR ( MIN ( {0} ) ), 1, 1 )\r\nVAR _EarliestDate_Safe = MIN ( _EarliestDate, DATE ( YEAR ( _Today ), 1, 1 ) )\r\n\r\nVAR _LatestDate = DATE ( YEAR ( MAX ( {1} ) ), 12, 31 )\r\nVAR _LatestDate_Safe = MAX ( _LatestDate, DATE ( YEAR ( _Today ), 12, 31 ) )\r\n\r\nVAR _Base_Calendar = CALENDAR ( _EarliestDate_Safe, _LatestDate_Safe )\r\n\r\nVAR _IntermediateResult =\r\n    ADDCOLUMNS (\r\n        _Base_Calendar,\r\n        \"\"Year\"\", YEAR ( [Date] ),\r\n        \"\"Quarter no\"\", QUARTER ( [Date] ),\r\n        \"\"Quarter\"\", \"\"Q\"\" & CONVERT ( QUARTER ( [Date] ), STRING ),\r\n        \"\"Year quarter\"\", CONVERT ( YEAR ( [Date] ), STRING ) & \"\" Q\"\" & CONVERT ( QUARTER ( [Date] ), STRING ),\r\n        \"\"Month no\"\", MONTH ( [Date] ),\r\n        \"\"Month name\"\", FORMAT ( [Date], \"\"MMMM\"\" ),\r\n        \"\"Month short name\"\", FORMAT ( [Date], \"\"MMM\"\" ),\r\n        \"\"Year month\"\", CONVERT ( YEAR ( [Date] ), STRING ) & \"\"-\"\" & FORMAT ( MONTH ( [Date] ), \"\"00\"\" ),\r\n        \"\"Year month no\"\", YEAR ( [Date] ) * 100 + MONTH ( [Date] ),\r\n        \"\"Month name Year\"\", FORMAT ( [Date], \"\"MMM YY\"\" ),\r\n        \"\"ISO week\"\", WEEKNUM ( [Date], 21 ),\r\n        \"\"ISO year\"\", YEAR ( [Date] + (26 - WEEKNUM ( [Date], 21 )) ),\r\n        \"\"Day name\"\", FORMAT ( [Date], \"\"DDDD\"\" ),\r\n        \"\"Day no of Week\"\", WEEKDAY ( [Date], 3 ),\r\n        \"\"Day no of Month\"\", DAY ( [Date] ),\r\n        \"\"Date_Key\"\", YEAR ( [Date] ) * 10000 + MONTH ( [Date] ) * 100 + DAY ( [Date] ),\r\n        \"\"Year slicer\"\", IF ( YEAR ( [Date] ) = YEAR ( TODAY() ), \"\"Current Year\"\", CONVERT ( YEAR ( [Date] ), STRING ) ),\r\n        \"\"Year month slicer\"\", IF ( AND ( MONTH ( [Date] ) = MONTH ( TODAY() ), YEAR ( [Date] ) = YEAR ( TODAY() ) ), \"\"Current month\"\", CONVERT ( YEAR ( [Date] ), STRING ) & \"\"-\"\" & FORMAT ( MONTH ( [Date] ), \"\"00\"\" ) ),\r\n        \"\"Date slicer\"\", IF ( [Date] = TODAY(), \"\"Today\"\", IF ( [Date] = TODAY() - 1, \"\"Yesterday\"\", CONVERT ( [Date], STRING ) ) ),\r\n        \"\"is_History\"\", IF ( [Date] <= TODAY(), 1, 0 ),\r\n        \"\"is_Weekend\"\", WEEKDAY ( [Date], 3 ) IN {{5,6}}\r\n    )\r\n\r\nVAR _Result =\r\n    ADDCOLUMNS (\r\n        _IntermediateResult,\r\n        \"\"ISO year week\"\", CONVERT ( [ISO year], STRING ) & \"\"-W\"\" & FORMAT ( [ISO week], \"\"00\"\" ),\r\n        \"\"Week slicer\"\",\r\n            VAR CurrentDate = TODAY()\r\n            VAR ThursdayOfWeek = CurrentDate + (3 - WEEKDAY ( CurrentDate, 2 ))\r\n            VAR ThursdayToday = YEAR ( ThursdayOfWeek )\r\n            RETURN IF (\r\n                AND (\r\n                    ThursdayToday = [ISO year],\r\n                    WEEKNUM ( TODAY(), 21 ) = [ISO week]\r\n                ),\r\n                \"\"Current week\"\",\r\n                CONVERT ( [ISO year], STRING ) & \"\"-W\"\" & FORMAT ( [ISO week], \"\"00\"\" )\r\n            )\r\n    )\r\nRETURN _Result\", _EarliestDateInput, _LatestDateInput);\r\n\r\n    // Create calculated table\r\n    var _date = Model.AddCalculatedTable(\"Calendar\", _DateDaxExpression);\r\n\r\n    // Mark as date table and assign group\r\n    _date.DataCategory = \"Time\";\r\n\r\n    // Remove summarization from int columns\r\n    foreach (var column in _date.Columns.Where(c => c.DataType == DataType.Int64))\r\n        column.SummarizeBy = AggregateFunction.None;\r\n\r\n    // Apply date format to datetime columns\r\n    foreach (var column in _date.Columns.Where(c => c.DataType == DataType.DateTime))\r\n        column.FormatString = \"mm/dd/yyyy\";\r\n\r\n    Info(string.Format(\"Created a new, organized 'Calendar' table.\\nEarliest Date: {0}\\nLatest Date: {1}\", _EarliestDateInput, _LatestDateInput));\r\n}\r\ncatch (Exception ex)\r\n{\r\n    Error(\"An unexpected error occurred while creating the Calendar table: \" + ex.Message);\r\n}\r\n",
      "Tooltip": "Creates a calculated date table. Needs to be saved before organizing it",
      "ValidContexts": "Model"
    },
    {
      "Name": "1. Create Table\\1. Create Calculated Measure Table",
      "Enabled": "true",
      "Execute": "using System;\r\nusing System.Windows.Forms;\r\nusing System.Linq;\r\n\r\npublic class InputDialog\r\n{\r\n    public static string ShowInputDialog(string text, string caption, string defaultValue)\r\n    {\r\n        Form prompt = new Form()\r\n        {\r\n            Width = 600,\r\n            Height = 150,\r\n            FormBorderStyle = FormBorderStyle.FixedDialog,\r\n            Text = caption,\r\n            StartPosition = FormStartPosition.CenterScreen\r\n        };\r\n        Label textLabel = new Label() { Left = 50, Top = 20, Text = text, AutoSize = true };\r\n        TextBox textBox = new TextBox() { Left = 50, Top = 50, Width = 500, Text = defaultValue };\r\n        Button confirmation = new Button() { Text = \"OK\", Left = 450, Width = 100, Top = 70, DialogResult = DialogResult.OK };\r\n        confirmation.Click += (sender, e) => { prompt.Close(); };\r\n        prompt.Controls.Add(textLabel);\r\n        prompt.Controls.Add(textBox);\r\n        prompt.Controls.Add(confirmation);\r\n        prompt.AcceptButton = confirmation;\r\n\r\n        return prompt.ShowDialog() == DialogResult.OK ? textBox.Text : \"\";\r\n    }\r\n}\r\n\r\nApplication.UseWaitCursor = false;\r\n\r\nstring defaultTableName = \"Model Measures\";\r\nstring tableName = InputDialog.ShowInputDialog(\"Enter name for the measure table:\", \"Create Measure Table\", defaultTableName);\r\n\r\nif (string.IsNullOrWhiteSpace(tableName))\r\n{\r\n    Info(\"Table name was not provided. Operation cancelled.\");\r\n    return;\r\n}\r\n\r\n// Check if table already exists\r\nif (Model.Tables.Any(t => t.Name == tableName))\r\n{\r\n    Info(\"A table named '\" + tableName + \"' already exists. No action taken.\");\r\n    return;\r\n}\r\n\r\ntry\r\n{\r\n    string daxTable = \"DATATABLE(\\\"MeasureName\\\", STRING, {{\\\"Default Measure\\\"}})\";\r\n    var newTable = Model.AddCalculatedTable(tableName, daxTable);\r\n\r\n    if (newTable != null)\r\n    {\r\n        newTable.Description = \"Table to collect measures\";\r\n        foreach (var col in newTable.Columns)\r\n        {\r\n            col.IsHidden = true;\r\n        }\r\n\r\n        //  Info(\"Successfully created calculated table '\" + tableName + \"' for storing measures.\");\r\n    }\r\n    else\r\n    {\r\n        Info(\"Failed to create the calculated table '\" + tableName + \"'.\");\r\n    }\r\n}\r\ncatch (Exception ex)\r\n{\r\n    Info(\"Error during calculated table creation:\\n\\n\" + ex.Message);\r\n}\r\n",
      "Tooltip": "Creats a calculated measure table with input name. For use when writing to table object is not an option",
      "ValidContexts": "Model"
    },
    {
      "Name": "2. Modify Table\\2. Mark as date-table and create measures + relationship",
      "Enabled": "true",
      "Execute": "\r\n // Title: Initial formatting of Date-Table\r\n // \r\n // Author: Eivind Haugen\r\n // \r\n // This script, when executed, will perform necessary and generic operations for a date table. The following steps are applied:\r\n // 1. Select the date column and mark it as a date-table\r\n // 2. Create measures that later can be applied to hide future dates in time calculation, either by:\r\n //        2a: The minimum of the selected date in the applied filter from the calendar or today\r\n //        2b: Last fact date, selected date from a fact table\r\n // 3. Setting up relationship to a fact table, the same date used as the last fact date\r\n //          NB! If more fact-tables, it will have to be done manually\r\n // 4. Apply best practice:\r\n //       4a: Ensure that numeric columns are not summarized\r\n //       4b: Apply a format string for the date-columns MM/DD/YYYY (as this is the condition in best-practice analyzer) \r\n \r\n\r\n\r\n\r\nusing System.Windows.Forms;\r\nScriptHelper.WaitFormVisible = false;\r\n\r\n// Use the selected table from the UI\r\nif (Selected.Table == null)\r\n{\r\n    Error(\"No table selected in the UI. Please select a table before running the script.\");\r\n    return;\r\n}\r\n\r\nstring _CalendarTable = Selected.Table.Name;\r\n    try\r\n    {\r\n        // Select a column to mark as date key\r\n        var _dateTableColumns = Model.AllColumns\r\n            .Where(col => col.Table.Name == _CalendarTable && col.DataType == DataType.DateTime)\r\n            .ToList();\r\n\r\n        if (_dateTableColumns.Count == 0)\r\n        {\r\n            Error(\"No columns with a valid date format found in the selected table.\");\r\n            return;\r\n        }\r\n\r\n        string _dateColumn = SelectColumn(_dateTableColumns, null, \"Select date-key to mark as date table\").DaxObjectFullName;\r\n\r\n        string _selectedColumnName = _dateColumn.Split('[', ']')[1];\r\n        string _CalendarTableName = _dateColumn.Split('\\'')[1];\r\n\r\n        Model.Tables[_CalendarTable].DataCategory = \"Time\";\r\n        Model.Tables[_CalendarTable].Columns[_selectedColumnName].IsKey = true;\r\n\r\n        // Select date column from a fact table\r\n        var otherTables = Model.Tables.Where(t => t.DataCategory != \"Time\");\r\n        var _dateOtherTables = otherTables\r\n            .SelectMany(t => t.Columns)\r\n            .Where(c => c.DataType == DataType.DateTime)\r\n            .ToList();\r\n\r\n            string _factDateCalendar = SelectColumn(_dateOtherTables, null, \"Select date from fact-table to Create Measure for the Last date\").DaxObjectFullName;\r\n        string _FactTable = _factDateCalendar.Split('[')[0].Trim('\\'');\r\n\r\n        // Measure 1: Max Calendar Date\r\n        string measureExpression = string.Format(\"MIN(MAX({0}), TODAY())\", _dateColumn);\r\n        string normalizedExpression = measureExpression.Replace(\" \", \"\").Replace(\"\\n\", \"\").Replace(\"\\r\", \"\").Replace(\"\\t\", \"\");\r\n\r\n        bool measureExists = Model.AllMeasures.Any(m =>\r\n            m.Expression.Replace(\" \", \"\").Replace(\"\\n\", \"\").Replace(\"\\r\", \"\").Replace(\"\\t\", \"\") == normalizedExpression\r\n        );\r\n\r\n        if (!measureExists)\r\n        {\r\n            var measure1 = Model.Tables[_CalendarTable].AddMeasure(\"Max Calendar date\");\r\n            measure1.DisplayFolder = \"0. Date Control measures\";\r\n            measure1.FormatString = \"dd-MM-yyyy\";\r\n            measure1.Description = \"The last date selected from a slicer from calendar. Setting today() if last date is after today's date.\";\r\n            measure1.Expression = measureExpression;\r\n        }\r\n\r\n        // Measure 2: Last Fact Table Date\r\n        string transactionMeasureExpression = string.Format(\"CALCULATE(MAX({0}), ALL ('{1}'))\", _factDateCalendar, _FactTable);\r\n        string normalizedTransactionExpression = transactionMeasureExpression.Replace(\" \", \"\").Replace(\"\\n\", \"\").Replace(\"\\r\", \"\").Replace(\"\\t\", \"\");\r\n\r\n        bool transactionMeasureExists = Model.AllMeasures.Any(m =>\r\n            m.Expression.Replace(\" \", \"\").Replace(\"\\n\", \"\").Replace(\"\\r\", \"\").Replace(\"\\t\", \"\") == normalizedTransactionExpression\r\n        );\r\n\r\n        if (!transactionMeasureExists)\r\n        {\r\n            var measure2 = Model.Tables[_CalendarTable].AddMeasure(\"Last fact table date\");\r\n            measure2.DisplayFolder = \"0. Date Control measures\";\r\n            measure2.FormatString = \"dd-MM-yyyy\";\r\n            measure2.Description = \"The last fact table date.\";\r\n            measure2.Expression = transactionMeasureExpression;\r\n        }\r\n\r\n        // Apply best practices\r\n        foreach (var column in Model.Tables[_CalendarTable].Columns)\r\n        {\r\n            if (column.DataType == DataType.Int64)\r\n                column.SummarizeBy = AggregateFunction.None;\r\n        }\r\n\r\n        // Create Relationship (only if not exists)\r\n        string _factDateColumnName = _factDateCalendar.Split('[')[1].TrimEnd(']');\r\n        var existingRelationship = Model.Relationships.FirstOrDefault(rel =>\r\n            rel.ToTable.Name == _CalendarTableName &&\r\n            rel.ToColumn.Name == _selectedColumnName\r\n        );\r\n\r\nif (existingRelationship == null)\r\n{\r\n    string message = string.Format(\r\n        \"No existing relationship found between '{0}'[{1}] and '{2}'[{3}].\\n\\nDo you want to create it?\",\r\n        _FactTable, _factDateColumnName, _CalendarTableName, _selectedColumnName\r\n    );\r\n\r\n    var result = MessageBox.Show(\r\n        message,\r\n        \"Create Relationship?\",\r\n        MessageBoxButtons.YesNo,\r\n        MessageBoxIcon.Question\r\n    );\r\n\r\n    if (result == DialogResult.Yes)\r\n    {\r\n        var calendarTable = Model.Tables[_CalendarTableName];\r\n        var factTable = Model.Tables[_FactTable];\r\n        var fromColumn = factTable.Columns[_factDateColumnName];\r\n        var toColumn = calendarTable.Columns[_selectedColumnName];\r\n\r\n        if (fromColumn != null && toColumn != null)\r\n        {\r\n            var rel = Model.AddRelationship();\r\n            rel.FromColumn = fromColumn;\r\n            rel.ToColumn = toColumn;\r\n            rel.FromCardinality = RelationshipEndCardinality.Many;\r\n            rel.ToCardinality = RelationshipEndCardinality.One;\r\n            rel.IsActive = true;\r\n\r\n            Output(string.Format(\r\n                \"Relationship created between '{0}'[{1}] and '{2}'[{3}].\",\r\n                _FactTable, _factDateColumnName, _CalendarTableName, _selectedColumnName\r\n            ));\r\n        }\r\n        else\r\n        {\r\n            Error(\"Could not find valid columns to create the relationship.\");\r\n        }\r\n    }\r\n    else\r\n    {\r\n        Output(\"User chose not to create the relationship.\");\r\n    }\r\n}\r\nelse\r\n{\r\n    Output(\"Relationship already exists between calendar and fact table.\");\r\n}\r\n\r\n    }\r\n    catch\r\n    {\r\n        Error(\"No date-key selected to mark as date table.\");\r\n    }\r\n",
      "Tooltip": "For selected date table: In addition to marking as date-table, it creates measures for date control in time intelligence and gives option to connect to date-column",
      "ValidContexts": "Table"
    },
    {
      "Name": "2. Modify Table\\2. Organize Calculated Date-table",
      "Enabled": "true",
      "Execute": "// Script to perform maintenance on the date-table in the Contoso dataset.\r\n// Needs a table on the same format with the same columns, or it needs to be modified\r\n\r\n\r\n// Hide the 'Running Macro' spinbox\r\nScriptHelper.WaitFormVisible = false;\r\n\r\nif (Selected.Table == null)\r\n{\r\n    Error(\"No table selected in the UI. Please select a date table before running the script.\");\r\n    return;\r\n}\r\n\r\nstring _CalendarTable = Selected.Table.Name;\r\n\r\ntry\r\n{\r\n    var table = Model.Tables[_CalendarTable];\r\n\r\n    // Sorting\r\n     table.Columns[\"Month name\"].SortByColumn = table.Columns[\"Month no\"];\r\n        table.Columns[\"Month short name\"].SortByColumn = table.Columns[\"Month no\"];\r\n        table.Columns[\"Year month\"].SortByColumn = table.Columns[\"Year month no\"];\r\n        table.Columns[\"Month name Year\"].SortByColumn = table.Columns[\"Year month no\"];\r\n        table.Columns[\"Day name\"].SortByColumn = table.Columns[\"Day no of week\"];\r\n        table.Columns[\"Year slicer\"].SortByColumn = table.Columns[\"Year\"];\r\n        table.Columns[\"Year month slicer\"].SortByColumn = table.Columns[\"Year month no\"];\r\n        table.Columns[\"Week slicer\"].SortByColumn = table.Columns[\"ISO year week\"];\r\n        table.Columns[\"Date slicer\"].SortByColumn = table.Columns[\"Date\"];\r\n    \r\n        // Sisplay Folders\r\n    string slicerFolder = \"1. Slicer\";\r\n    string yearFolder = \"2. Year\";\r\n    string quarterFolder = \"3. Quarter\";\r\n    string monthFolder = \"4. Month\";\r\n    string weekFolder = \"5. Week\";\r\n    string dateFolder = \"6. Date\";\r\n    string dayFolder = \"7. Day\";\r\n    string booleanFolder = \"8. Boolean\";\r\n\r\n    // Slicer\r\n    table.Columns[\"Year slicer\"].DisplayFolder = slicerFolder;\r\n    table.Columns[\"Year month slicer\"].DisplayFolder = slicerFolder;\r\n    table.Columns[\"Week slicer\"].DisplayFolder = slicerFolder;\r\n    table.Columns[\"Date slicer\"].DisplayFolder = slicerFolder;\r\n\r\n    // Year\r\n    table.Columns[\"Year\"].DisplayFolder = yearFolder;\r\n\r\n    // Quarter\r\n    table.Columns[\"Quarter\"].DisplayFolder = quarterFolder;\r\n    table.Columns[\"Quarter no\"].DisplayFolder = quarterFolder;\r\n    table.Columns[\"Year quarter\"].DisplayFolder = quarterFolder;\r\n\r\n    // Month\r\n    table.Columns[\"Month no\"].DisplayFolder = monthFolder;\r\n    table.Columns[\"Month name\"].DisplayFolder = monthFolder;\r\n    table.Columns[\"Month short name\"].DisplayFolder = monthFolder;\r\n    table.Columns[\"Year month\"].DisplayFolder = monthFolder;\r\n    table.Columns[\"Year month no\"].DisplayFolder = monthFolder;\r\n    table.Columns[\"Month name Year\"].DisplayFolder = monthFolder;\r\n\r\n    // Week\r\n    table.Columns[\"ISO week\"].DisplayFolder = weekFolder;\r\n    table.Columns[\"ISO year\"].DisplayFolder = weekFolder;\r\n    table.Columns[\"ISO year week\"].DisplayFolder = weekFolder;\r\n\r\n    // Date\r\n    table.Columns[\"Date\"].DisplayFolder = dateFolder;\r\n    table.Columns[\"Date_Key\"].DisplayFolder = dateFolder;\r\n\r\n    // Day\r\n    table.Columns[\"Day name\"].DisplayFolder = dayFolder;\r\n    table.Columns[\"Day no of Week\"].DisplayFolder = dayFolder;\r\n    table.Columns[\"Day no of Month\"].DisplayFolder = dayFolder;\r\n\r\n    // Boolean\r\n    table.Columns[\"is_History\"].DisplayFolder = booleanFolder;\r\n    table.Columns[\"is_Weekend\"].DisplayFolder = booleanFolder;\r\n\r\n    // Format Strings\r\n    table.Columns[\"Date\"].FormatString = \"mm/dd/yyyy\";\r\n    table.Columns[\"Date_Key\"].FormatString = \"0\";\r\n    table.Columns[\"Day no of Month\"].FormatString = \"0\";\r\n    table.Columns[\"Day no of Week\"].FormatString = \"0\";\r\n    table.Columns[\"is_History\"].FormatString = \"0\";\r\n    table.Columns[\"ISO week\"].FormatString = \"0\";\r\n    table.Columns[\"ISO year\"].FormatString = \"0\";\r\n    table.Columns[\"Month no\"].FormatString = \"0\";\r\n    table.Columns[\"Quarter no\"].FormatString = \"0\";\r\n    table.Columns[\"Year\"].FormatString = \"0\";\r\n    table.Columns[\"Year month no\"].FormatString = \"0\";\r\n\r\n    // Hide Unused Columns\r\n    table.Columns[\"Date_Key\"].IsHidden = true;\r\n    table.Columns[\"Date_Key\"].IsAvailableInMDX = false;\r\n\r\n    // Column Descriptions\r\n    table.Columns[\"Date\"].Description = \"YYYY-MM-DD\";\r\n    table.Columns[\"Date_Key\"].Description = \"YYYYMMDD\";\r\n    table.Columns[\"Date slicer\"].Description = \"Today, yesterday or date\";\r\n\r\n    table.Columns[\"Year\"].Description = \"YYYY\";\r\n    table.Columns[\"Year slicer\"].Description = \"Current year, or YYYY\";\r\n\r\n    table.Columns[\"Quarter no\"].Description = \"1, 2, 3 or 4\";\r\n    table.Columns[\"Quarter\"].Description = \"e.g., Q1\";\r\n    table.Columns[\"Year quarter\"].Description = \"2024 Q1\";\r\n\r\n    table.Columns[\"Month no\"].Description = \"MM\";\r\n    table.Columns[\"Month name\"].Description = \"e.g., January\";\r\n    table.Columns[\"Month short name\"].Description = \"e.g., Jan\";\r\n    table.Columns[\"Year month\"].Description = \"YYYY-MM\";\r\n    table.Columns[\"Year month no\"].Description = \"YYYYMM\";\r\n    table.Columns[\"Month name Year\"].Description = \"e.g., Jan 2024\";\r\n    table.Columns[\"Year month slicer\"].Description = \"Current month or YYYY-MM\";\r\n\r\n    table.Columns[\"ISO year\"].Description = \"ISO year (YYYY)\";\r\n    table.Columns[\"ISO week\"].Description = \"ISO week number\";\r\n    table.Columns[\"ISO year week\"].Description = \"e.g., 2024 W01\";\r\n    table.Columns[\"Week slicer\"].Description = \"Current week or ISO year week\";\r\n\r\n    table.Columns[\"Day no of Month\"].Description = \"Day number 1-31\";\r\n    table.Columns[\"Day no of Week\"].Description = \"0=Monday to 6=Sunday\";\r\n    table.Columns[\"Day name\"].Description = \"e.g., Monday\";\r\n\r\n    table.Columns[\"is_Weekend\"].Description = \"1 if weekend, else 0\";\r\n    table.Columns[\"is_History\"].Description = \"1 if today or earlier\";\r\n\r\n    // 8. Table description\r\n    table.Description = \"Date-table\";\r\n}\r\ncatch\r\n{\r\n    Error(\"No selected date-table or see if column definitions are matching => No formatting\");\r\n}\r\n",
      "Tooltip": "For selected date-table (when refreshed): Organizes the Calculated date-table with folders, sort by column and best practice rules",
      "ValidContexts": "Table"
    },
    {
      "Name": "2. Modify Table\\2. Organize Contoso Date-table",
      "Enabled": "true",
      "Execute": "// Script to perform maintenance on the date-table in the Contoso dataset.\r\n// Needs a table on the same format with the same columns, or it needs to be modified\r\n\r\n\r\n// Hide the 'Running Macro' spinbox\r\nScriptHelper.WaitFormVisible = false;\r\n\r\nif (Selected.Table == null)\r\n{\r\n    Error(\"No table selected in the UI. Please select a date table before running the script.\");\r\n    return;\r\n}\r\n\r\nstring _CalendarTable = Selected.Table.Name;\r\n\r\ntry\r\n{\r\n    var table = Model.Tables[_CalendarTable];\r\n\r\n    // Sorting\r\n    table.Columns[\"Year Quarter\"].SortByColumn = table.Columns[\"Year Quarter Number\"];\r\n    table.Columns[\"Year Month Short\"].SortByColumn = table.Columns[\"Year Month Number\"];\r\n    table.Columns[\"Year Month\"].SortByColumn = table.Columns[\"Year Month Number\"];\r\n    table.Columns[\"Month\"].SortByColumn = table.Columns[\"Month Number\"];\r\n    table.Columns[\"Month Short\"].SortByColumn = table.Columns[\"Month Number\"];\r\n    table.Columns[\"Day of Week\"].SortByColumn = table.Columns[\"Day of Week Number\"];\r\n    table.Columns[\"Day of Week Short\"].SortByColumn = table.Columns[\"Day of Week Number\"];\r\n\r\n    // Display folders\r\n    table.Columns[\"Year\"].DisplayFolder = \"1. Year\";\r\n\r\n    table.Columns[\"Year Quarter\"].DisplayFolder = \"2. Quarter\";\r\n    table.Columns[\"Year Quarter Number\"].DisplayFolder = \"2. Quarter\";\r\n    table.Columns[\"Quarter\"].DisplayFolder = \"2. Quarter\";\r\n\r\n    table.Columns[\"Year Month\"].DisplayFolder = \"3. Month\";\r\n    table.Columns[\"Year Month Short\"].DisplayFolder = \"3. Month\";\r\n    table.Columns[\"Year Month Number\"].DisplayFolder = \"3. Month\";\r\n    table.Columns[\"Month\"].DisplayFolder = \"3. Month\";\r\n    table.Columns[\"Month Short\"].DisplayFolder = \"3. Month\";\r\n    table.Columns[\"Month Number\"].DisplayFolder = \"3. Month\";\r\n\r\n    table.Columns[\"Date\"].DisplayFolder = \"4. Date\";\r\n\r\n    table.Columns[\"Day of Week\"].DisplayFolder = \"5. Day\";\r\n    table.Columns[\"Day of Week Short\"].DisplayFolder = \"5. Day\";\r\n    table.Columns[\"Day of Week Number\"].DisplayFolder = \"5. Day\";\r\n    table.Columns[\"Working Day\"].DisplayFolder = \"5. Day\";\r\n    table.Columns[\"Working Day Number\"].DisplayFolder = \"5. Day\";\r\n\r\n    // Format strings\r\n    table.Columns[\"Date\"].FormatString = \"mm/dd/yyyy\";\r\n\r\n    table.Columns[\"Year Quarter Number\"].FormatString = \"0\";\r\n    table.Columns[\"Year Month Number\"].FormatString = \"0\";\r\n    table.Columns[\"Month Number\"].FormatString = \"0\";\r\n    table.Columns[\"Day of Week Number\"].FormatString = \"0\";\r\n    table.Columns[\"Working Day Number\"].FormatString = \"0\";\r\n\r\n    // Hide columns used only for sorting\r\n    table.Columns[\"Year Quarter Number\"].IsHidden = true;\r\n    table.Columns[\"Year Month Number\"].IsHidden = true;\r\n\r\n    // Descriptions\r\n    table.Columns[\"Date\"].Description = \"YYYY-MM-DD\";\r\n    table.Columns[\"Year\"].Description = \"YYYY\";\r\n\r\n    table.Columns[\"Year Quarter\"].Description = \"Q1 2024\";\r\n    table.Columns[\"Year Quarter Number\"].Description = \"Used for sorting Year Quarter\";\r\n    table.Columns[\"Quarter\"].Description = \"I.e. Q1\";\r\n\r\n    table.Columns[\"Year Month\"].Description = \"I.e. January 2024\";\r\n    table.Columns[\"Year Month Short\"].Description = \"I.e. Jan 2024\";\r\n    table.Columns[\"Year Month Number\"].Description = \"Used for sorting Year Month\";\r\n    table.Columns[\"Month\"].Description = \"I.e. January\";\r\n    table.Columns[\"Month Short\"].Description = \"I.e. Jan\";\r\n    table.Columns[\"Month Number\"].Description = \"I.e. 1 (=January)\";\r\n\r\n    table.Columns[\"Day of Week\"].Description = \"I.e. Monday\";\r\n    table.Columns[\"Day of Week Short\"].Description = \"I.e. Mon\";\r\n    table.Columns[\"Day of Week Number\"].Description = \"1=Sunday to 7=Saturday\";\r\n    table.Columns[\"Working day\"].Description = \"TRUE/FALSE\";\r\n    table.Columns[\"Working Day Number\"].Description = \"Accumulated work day no from first date in calendar\";\r\n\r\n    // Table description\r\n    table.Description = \"Date-table\";\r\n}\r\ncatch\r\n{\r\n    Error(\"No selected date-table or see if column definitions are matching => No formatting\");\r\n}\r\n",
      "Tooltip": "For selected date-table: Organizes the Contoso date-table with folders, sort by column and best practice rules",
      "ValidContexts": "Table"
    },
    {
      "Name": "3. Calculation Groups and FP\\3. Add items to Time Intelligence Calculation group",
      "Enabled": "true",
      "Execute": "\r\n// This script includes the select time calculations that are to be included. The idea is from the following script, but here it is included as a Calculation Group instead and with some modifications\r\n//        Data-Goblin inspiration: https://github.com/data-goblin/powerbi-macguyver-toolbox/blob/main/tabular-editor-scripts/csharp-scripts/add-dax-templates/add-time-intelligence.csx\r\n\r\n\r\n// There are some input that are dynamically included in the generation of time intelligence calculations:\r\n//     1. Date column to be used from the date table (needs to be created first)\r\n//     2. Measure that shows the last data from calendar or transaction (needs to be calculated first and have the correct formatString containing \"yy\"). The purpose is to hide future dates in calculations, where applicable\r\n//     3. Based on the selected Time intelligence calculations, it is logic on which input is required. \r\n\r\n// Naming is aiming at following this pattern: https://www.daxpatterns.com/standard-time-related-calculations/\r\n// Referance to source for the expressions are included in the measure expressions\r\n\r\n// If you know of some measures with % format, this can be updated in the logic for the calculation item before running the script\r\n\r\n\r\n\r\n#r \"System.Drawing\"\r\nusing System.Windows.Forms;\r\nusing System.Drawing;\r\nusing System.Linq;\r\nusing System.Collections.Generic;\r\n\r\n\r\n// Don't show the script execution dialog or cursor\r\nScriptHelper.WaitFormVisible = false;\r\nApplication.UseWaitCursor = false;\r\n\r\n\r\n// ─────────────────────────────────────────────────────────────\r\n// Rename Calculation Group Table and Column if it's a new one\r\n\r\n// Define inline input dialog function \r\nFunc<string, string, string, string> ShowInputDialog = (text, caption, defaultValue) =>\r\n{\r\n    Form prompt = new Form()\r\n    {\r\n        Width = 600,\r\n        Height = 150,\r\n        FormBorderStyle = FormBorderStyle.FixedDialog,\r\n        Text = caption,\r\n        StartPosition = FormStartPosition.CenterScreen\r\n    };\r\n    Label textLabel = new Label() { Left = 50, Top = 20, Text = text, AutoSize = true };\r\n    TextBox textBox = new TextBox() { Left = 50, Top = 50, Width = 500, Text = defaultValue };\r\n    Button confirmation = new Button() { Text = \"OK\", Left = 450, Width = 100, Top = 70, DialogResult = DialogResult.OK };\r\n    confirmation.Click += (sender, e) => { prompt.Close(); };\r\n    prompt.Controls.Add(textLabel);\r\n    prompt.Controls.Add(textBox);\r\n    prompt.Controls.Add(confirmation);\r\n    prompt.AcceptButton = confirmation;\r\n\r\n    return prompt.ShowDialog() == DialogResult.OK ? textBox.Text : \"\";\r\n};\r\n\r\n// Get the selected calculation group table. Checks the name if it is a new or existing calculation group\r\nvar cgTable = Selected.Tables.First() as CalculationGroupTable;\r\n\r\nif (cgTable != null && cgTable.Name.StartsWith(\"New Calculation Group\"))\r\n{\r\n    string defaultTableName = \"Time Intelligence\";\r\n    string defaultColumnName = \"Time Calculation\";\r\n\r\n    string newTableName = ShowInputDialog(\r\n        \"Enter new name for the calculation group table:\",\r\n        \"Rename Calculation Group Table\",\r\n        defaultTableName\r\n    );\r\n\r\n    string newColumnName = ShowInputDialog(\r\n        \"Enter name for the calculation group column:\",\r\n        \"Set Calculation Group Column Name\",\r\n        defaultColumnName\r\n    );\r\n\r\n    if (!string.IsNullOrWhiteSpace(newTableName))\r\n    {\r\n        cgTable.Name = newTableName;\r\n        cgTable.Description = \"Calculation group for dynamic time intelligence.\";\r\n        cgTable.CalculationGroup.Precedence = 0;\r\n\r\nif (!string.IsNullOrWhiteSpace(newColumnName))\r\n{\r\n    cgTable.Columns[\"Name\"].Name = newColumnName;\r\n}\r\n\r\n        // Info(string.Format(\"Calculation Group renamed to '{0}' with column '{1}'\", newTableName, newColumnName));\r\n    }\r\n    else\r\n    {\r\n        Warning(\"No table name entered. Calculation group name remains unchanged.\");\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n// ─────────────────────────────────────────────────────────────\r\n// Helper: Column selector\r\nFunc<IEnumerable<Column>, string, Column> SelectColumnFromList = (columns, title) =>\r\n{\r\n    var form = new Form();\r\n    var listBox = new ListBox();\r\n    var okButton = new Button();\r\n    var cancelButton = new Button();\r\n    var label = new Label();\r\n\r\n    form.Text = \"Select Column\"; // Keep title short (multiline not supported)\r\n    form.Width = 400;\r\n    form.Height = 470;\r\n    form.FormBorderStyle = FormBorderStyle.FixedDialog;\r\n    form.StartPosition = FormStartPosition.CenterScreen;\r\n\r\n    label.Text = title;  // Use the existing title input as label text\r\n    label.Left = 10;\r\n    label.Top = 10;\r\n    label.Width = 360;\r\n    label.Height = 40;\r\n    label.AutoSize = false;\r\n\r\n    listBox.Width = 360;\r\n    listBox.Height = 280;\r\n    listBox.Left = 10;\r\n    listBox.Top = 60;\r\n    listBox.SelectionMode = SelectionMode.One;\r\n    listBox.DataSource = columns.Select(c => c.DaxObjectFullName).ToList();\r\n\r\n    okButton.Text = \"OK\";\r\n    okButton.Left = 220;\r\n    okButton.Top = 360;\r\n    okButton.DialogResult = DialogResult.OK;\r\n\r\n    cancelButton.Text = \"Cancel\";\r\n    cancelButton.Left = 300;\r\n    cancelButton.Top = 360;\r\n    cancelButton.DialogResult = DialogResult.Cancel;\r\n\r\n    form.Controls.Add(label);\r\n    form.Controls.Add(listBox);\r\n    form.Controls.Add(okButton);\r\n    form.Controls.Add(cancelButton);\r\n    form.AcceptButton = okButton;\r\n    form.CancelButton = cancelButton;\r\n\r\n    var result = form.ShowDialog();\r\n    if (result == DialogResult.OK && listBox.SelectedIndex >= 0)\r\n    {\r\n        string selectedName = listBox.SelectedItem.ToString();\r\n        return columns.FirstOrDefault(c => c.DaxObjectFullName == selectedName);\r\n    }\r\n    return null;\r\n};\r\n\r\n\r\n// ─────────────────────────────────────────────────────────────\r\n// Helper: Measure selector\r\nFunc<IEnumerable<Measure>, string, Measure> SelectMeasureFromList = (measures, title) =>\r\n{\r\n    var form = new Form();\r\n    var listBox = new ListBox();\r\n    var okButton = new Button();\r\n    var cancelButton = new Button();\r\n    var label = new Label();\r\n\r\n    form.Text = \"Select Measure\"; // Keep title short\r\n    form.Width = 400;\r\n    form.Height = 470;\r\n    form.FormBorderStyle = FormBorderStyle.FixedDialog;\r\n    form.StartPosition = FormStartPosition.CenterScreen;\r\n\r\n    label.Text = title;  // Use the existing title input as label text\r\n    label.Left = 10;\r\n    label.Top = 10;\r\n    label.Width = 360;\r\n    label.Height = 40;\r\n    label.AutoSize = false;\r\n\r\n    listBox.Width = 360;\r\n    listBox.Height = 280;\r\n    listBox.Left = 10;\r\n    listBox.Top = 60;\r\n    listBox.SelectionMode = SelectionMode.One;\r\n    listBox.DataSource = measures.Select(m => m.DaxObjectFullName).ToList();\r\n\r\n    okButton.Text = \"OK\";\r\n    okButton.Left = 220;\r\n    okButton.Top = 360;\r\n    okButton.DialogResult = DialogResult.OK;\r\n\r\n    cancelButton.Text = \"Cancel\";\r\n    cancelButton.Left = 300;\r\n    cancelButton.Top = 360;\r\n    cancelButton.DialogResult = DialogResult.Cancel;\r\n\r\n    form.Controls.Add(label);\r\n    form.Controls.Add(listBox);\r\n    form.Controls.Add(okButton);\r\n    form.Controls.Add(cancelButton);\r\n    form.AcceptButton = okButton;\r\n    form.CancelButton = cancelButton;\r\n\r\n    var result = form.ShowDialog();\r\n    if (result == DialogResult.OK && listBox.SelectedIndex >= 0)\r\n    {\r\n        string selectedName = listBox.SelectedItem.ToString();\r\n        return measures.FirstOrDefault(m => m.DaxObjectFullName == selectedName);\r\n    }\r\n    return null;\r\n};\r\n\r\n// ─────────────────────────────────────────────────────────────\r\n// Time Intelligence Selection UI\r\n\r\nstring[] calcTypes = new string[] {\r\n    \"Actual\", \"MTD\", \"QTD\", \"YTD\", \"R12\", \"Rolling average\", \"Rolling total\"\r\n};\r\n\r\nForm tiForm = new Form();\r\nListBox tiListBox = new ListBox();\r\nButton tiButton = new Button();\r\nLabel tiLabel = new Label();\r\n\r\ntiForm.Text = \"Select Time Intelligence Types\";\r\ntiForm.Width = 350;\r\ntiForm.Height = 400;\r\n\r\ntiLabel.Text = \"Select one or more calculation types:\";\r\ntiLabel.Location = new Point(20, 10);\r\ntiLabel.Width = 300;\r\n\r\ntiListBox.Items.AddRange(calcTypes);\r\ntiListBox.SelectionMode = SelectionMode.MultiExtended;\r\ntiListBox.Location = new Point(20, 40);\r\ntiListBox.Width = 290;\r\ntiListBox.Height = 250;\r\n\r\ntiButton.Text = \"OK\";\r\ntiButton.Location = new Point(120, 310);\r\ntiButton.Width = 100;\r\ntiButton.Click += (sender, e) => { tiForm.Close(); };\r\n\r\ntiForm.Controls.Add(tiListBox);\r\ntiForm.Controls.Add(tiButton);\r\ntiForm.Controls.Add(tiLabel);\r\ntiForm.ShowDialog();\r\n\r\nList<string> selectedValues = tiListBox.SelectedItems.Cast<string>().ToList();\r\n\r\n\r\n\r\n\r\nvar _dateColumns = Model.AllColumns.Where(c => c.DataType == DataType.DateTime &&\r\n    c.IsKey == true).ToList();\r\n    var selectedDateCol = SelectColumnFromList(\r\n    _dateColumns,\r\n    \"Select the DATE column for time calculations.\\n\\nA Date table marked as a date table is required.\"\r\n);\r\n\r\nif (selectedDateCol == null) return;\r\nstring _CalendarDate = selectedDateCol.DaxObjectFullName;\r\nvar _calendarTableName = _CalendarDate.Split('[')[0].Trim('\\'');\r\n\r\nstring _LastDateAvailable = null;\r\n\r\nbool requiresFutureDateLogic = selectedValues.Any(x => new[] { \"Actual\", \"MTD\", \"QTD\", \"YTD\", \"R12\", \"Rolling average\", \"Rolling total\" }.Contains(x));\r\nif (requiresFutureDateLogic)\r\n{\r\n    var _dateFormattedMeasures = Model.AllMeasures\r\n        .Where(m => m.FormatString != null && (m.FormatString.Contains(\"yy\") || m.FormatString.Contains(\"yyyy\")))\r\n        .ToList();\r\n\r\n        var selectedMeasure = SelectMeasureFromList(_dateFormattedMeasures, \"Select MEASURE for hiding future dates \\n\\n (Cancel will create logic for last date)\");\r\n    _LastDateAvailable = selectedMeasure != null\r\n        ? selectedMeasure.DaxObjectName\r\n        : string.Format(\"MIN(MAX({0}), TODAY())\", _CalendarDate);\r\n}\r\n\r\nstring _selectedAverage = null;\r\nif (selectedValues.Contains(\"Rolling average\"))\r\n{\r\n    var _selectedTableName = _CalendarDate.Split('[')[0].Trim('\\'');\r\n    var _selectedDateTable = Model.Tables[_selectedTableName];\r\n    var _columnsInDateTable = _selectedDateTable.Columns.ToList();\r\n\r\n    var avgCol = SelectColumnFromList(_columnsInDateTable, \"Select column for Rolling 12M Average \\n\\n(e.g., daily/monthly)\");\r\n    if (avgCol != null)\r\n    {\r\n        _selectedAverage = avgCol.DaxObjectFullName;\r\n    }\r\n}\r\n\r\n// Optional debug\r\n//string debugMsg = \"Selected: \" + string.Join(\", \", selectedValues);\r\n//debugMsg += \"\\nCalendar Date: \" + _CalendarDate;\r\n//debugMsg += _LastDateAvailable != null ? \"\\nLast Date Logic: \" + _LastDateAvailable : \"\";\r\n//debugMsg += _selectedAverage != null ? \"\\nRolling Average Column: \" + _selectedAverage : \"\";\r\n//MessageBox.Show(debugMsg);\r\n\r\n// Set starting ordinal\r\nint ordinal = cgTable.Name.StartsWith(\"New Calculation Group\") ? 0 :\r\n    (cgTable.CalculationItems.Count > 0 ? cgTable.CalculationItems.Max(ci => ci.Ordinal) + 1 : 0);\r\n        \r\n\r\n\r\n// ─────────────────────────────────────────────────────────────\r\n// AddCalculationItemIfNotExists helper\r\n\r\nList<string> skippedItems = new List<string>();\r\n\r\nAction<string, string, int, string, string> AddCalculationItemIfNotExists = \r\n(name, expression, ordinalPos, description, formatString) =>\r\n{\r\nif (cgTable.CalculationItems.Any(ci => ci.Name.Equals(name, System.StringComparison.OrdinalIgnoreCase)))\r\n{\r\n    skippedItems.Add(name);\r\n    return;\r\n}\r\n\r\n\r\n    var item = cgTable.AddCalculationItem(name);\r\n    item.Expression = expression;\r\n    item.Ordinal = ordinalPos;\r\n    item.Description = description;\r\n    // FormatDax(item);\r\n};\r\n\r\n\r\n// ─────────────────────────────────────────────────────────────\r\n// Looping through all selected calculation item categories\r\nforeach (var item in selectedValues)\r\n{\r\n\r\n    if (item == \"Actual\")\r\n    {\r\n        AddCalculationItemIfNotExists(\"Actual\", \"SELECTEDMEASURE()\", ordinal++, \"Actual values\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"Actual to date\", string.Format(@\"\r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\n    \r\nRETURN \r\n    CALCULATE(\r\n        SELECTEDMEASURE(),\r\n        _CurrentDates\r\n    )\", _LastDateAvailable, _CalendarDate), ordinal++, \"Actual value until last date available\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"Actual Y-1\", \r\n    string.Format(\r\n        \"CALCULATE(\\n\" +\r\n        \"    SELECTEDMEASURE(),\\n\" +\r\n        \"    SAMEPERIODLASTYEAR({0})\\n\" +\r\n        \")\", \r\n        _CalendarDate\r\n    ), \r\n    ordinal++, \"Actual value last year\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"Actual to date Y-1\", string.Format(@\"\r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\n    \r\nRETURN \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        SAMEPERIODLASTYEAR(_CurrentDates)\r\n    )\", \r\n_LastDateAvailable, \r\n_CalendarDate), ordinal++, \"Actual value last year, hiding future dates as of this year\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"AOA\", string.Format(@\"\r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\nVAR _thisyear = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(),\r\n        _CurrentDates\r\n    )\r\nVAR _lastyear = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        SAMEPERIODLASTYEAR(_CurrentDates)\r\n    )\r\n    \r\nRETURN \r\n    _thisyear - _lastyear\", _LastDateAvailable, _CalendarDate), ordinal++, \"AOA = Actual over Actual: Deviation for actual value this year and last year, hiding future dates\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"AOA %\", string.Format(@\"\r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\nVAR _thisyear = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        _CurrentDates\r\n        )\r\nVAR _lastyear = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        SAMEPERIODLASTYEAR(_CurrentDates)\r\n    )\r\nVAR _deviationYear = _thisyear - _lastyear\r\n\r\nRETURN \r\n    DIVIDE(_deviationYear, _lastyear)\", _LastDateAvailable, _CalendarDate), ordinal++, \"AOA %: Percentage change this year and last year, hiding future dates\", \"\\\"0%\\\"\");\r\n\r\n        AddCalculationItemIfNotExists(\"AOA C\", string.Format(@\"\r\nVAR _thisyear = SELECTEDMEASURE()\r\nVAR _lastyear = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        SAMEPERIODLASTYEAR({0})\r\n    )\r\n    \r\nRETURN \r\n    _thisyear - _lastyear\", _CalendarDate), ordinal++, \"AOA C = Complete Actual over Actual, not hiding future dates\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"AOA C %\", string.Format(@\"\r\nVAR _thisyear = SELECTEDMEASURE()\r\nVAR _lastyear = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        SAMEPERIODLASTYEAR({0})\r\n    )\r\nVAR _deviationYear = _thisyear - _lastyear\r\n\r\nRETURN \r\n    DIVIDE(_deviationYear, _lastyear)\", _CalendarDate), ordinal++, \"AOA C %: Complete Actual over Actual % change, not hiding future dates\", \"\\\"0%\\\"\");\r\n\r\n        continue;\r\n    }\r\n\r\n        // MTD logic\r\n    if (item == \"MTD\")\r\n    {\r\n        AddCalculationItemIfNotExists(\"MTD\", string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n\r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\n    \r\nRETURN \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESMTD(_CurrentDates)\r\n    )\", _LastDateAvailable, _CalendarDate), ordinal++, \"Accumulated Month to date, hiding future dates after last available date\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"MTD LY\", string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n        \r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\n    \r\nRETURN \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESMTD(SAMEPERIODLASTYEAR(_CurrentDates))\r\n    )\", _LastDateAvailable, _CalendarDate), ordinal++, \"Accumulated Month to date last year, hiding future dates from last available date (same date last year)\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"MOMTD\", string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n        \r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\nVAR _CurrentMonth = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESMTD(_CurrentDates)\r\n    )\r\nVAR _PreviousMonth = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESMTD(SAMEPERIODLASTYEAR(_CurrentDates))\r\n    )\r\n    \r\nRETURN \r\n    _CurrentMonth - _PreviousMonth\", _LastDateAvailable, _CalendarDate), ordinal++, \"MOMTD = Month over Month to date: Month-to-Date Deviation, this year and last year accumulated\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"MOMTD %\", string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n        \r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\nVAR _CurrentMonth = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESMTD(_CurrentDates)\r\n    )\r\nVAR _PreviousMonth = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESMTD(SAMEPERIODLASTYEAR(_CurrentDates))\r\n    )\r\nVAR _DeltaMonth = _CurrentMonth - _PreviousMonth\r\n\r\nRETURN \r\n    DIVIDE(_DeltaMonth, _PreviousMonth)\", _LastDateAvailable, _CalendarDate), ordinal++, \"MOMTD = Month over Month to date %: % change this year compared to last year accumulated\", \"\\\"0%\\\"\");\r\n\r\n        AddCalculationItemIfNotExists(\"MTD PM\", string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n\r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\n    \r\nRETURN \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESMTD(PREVIOUSMONTH(_CurrentDates))\r\n    )\", _LastDateAvailable, _CalendarDate), ordinal++, \"Accumulated Month to date previous Month, hiding future dates from last available date (same date last Month)\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"MTD PQ\", string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n        \r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\n    \r\nRETURN \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESMTD(PREVIOUSQUARTER(_CurrentDates))\r\n    )\", _LastDateAvailable, _CalendarDate), ordinal++, \"Accumulated Month to date previous Quarter, hiding future dates from last available date (same date last quarter)\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"MTD C\", string.Format(@\"CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESMTD({0})\r\n        )\"\r\n        , _CalendarDate), ordinal++, \"MTD C = Month to date Complete: accumulated, without hiding of future dates\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"MTD LY C\", string.Format(@\"CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESMTD(SAMEPERIODLASTYEAR({0}))\r\n        )\", \r\n        _CalendarDate), ordinal++, \"MTD LY C = Month to date Complete Last Year: Month last year accumulated, without hiding future dates\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"MTD PM C\", string.Format(@\"CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESMTD(PREVIOUSMONTH({0}))\r\n        )\", _CalendarDate), ordinal++, \"MTD PM C = Month to date, Previous month, Complete: Last Month previous month accumulated, without hiding future dates\", null);\r\n\r\n        continue;\r\n    }\r\n    \r\n // QTD logic\r\n    if (item == \"QTD\")\r\n    {\r\n        AddCalculationItemIfNotExists(\"QTD\", string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n        \r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\n    \r\nRETURN \r\n    \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESQTD(_CurrentDates)\r\n    )\", _LastDateAvailable, _CalendarDate), ordinal++, \"Accumulated quarter to date, hiding future dates after last available date\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"QTD LY\", string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n        \r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\n\r\nRETURN \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESQTD(SAMEPERIODLASTYEAR(_CurrentDates))\r\n    )\", _LastDateAvailable, _CalendarDate), ordinal++, \"Accumulated quarter to date last year, hiding future dates from last available date (same date last year)\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"QOQTD\", string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n      \r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\nVAR _CurrentYear = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESQTD(_CurrentDates)\r\n     )\r\nVAR _PreviousYear = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESQTD(SAMEPERIODLASTYEAR(_CurrentDates))\r\n    )\r\n\r\nRETURN \r\n    _CurrentYear - _PreviousYear\", _LastDateAvailable, _CalendarDate), ordinal++, \"QOQTD = Quarter over Quarter to date: Quarter-to-Date Deviation, this year and last year accumulated\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"QOQTD %\", string.Format(@\"\r\n// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n\r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\nVAR _CurrentYear = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESQTD(_CurrentDates)\r\n    )\r\nVAR _PreviousYear = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESQTD(SAMEPERIODLASTYEAR(_CurrentDates))\r\n    )\r\nVAR _DeltaYear = _CurrentYear - _PreviousYear\r\n\r\nRETURN \r\n    DIVIDE(_DeltaYear, _PreviousYear)\", _LastDateAvailable, _CalendarDate), ordinal++, \"QOQTD = Quarter over Quarter to date: Quarter-to-Date Index, % change this year compared to last year accumulated\", \"\\\"0%\\\"\");\r\n\r\n        AddCalculationItemIfNotExists(\"QTD C\", string.Format(@\"CALCULATE(\r\n     SELECTEDMEASURE(), \r\n     DATESQTD({0})\r\n     )\", _CalendarDate), ordinal++, \"QTD C = Quarter to date Complete: Quarter to date accumulated, without hiding future dates\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"QTD LY C\", string.Format(@\"CALCULATE(\r\n    SELECTEDMEASURE(), \r\n    DATESQTD(SAMEPERIODLASTYEAR({0}))\r\n    )\", _CalendarDate), ordinal++, \"QTD LY C = Quarter to date last year Complete: Last Quarter accumulated, without hiding future dates\", null);\r\n\r\n        continue;\r\n    }\r\n\r\n// YTD logic\r\nif (item == \"YTD\")\r\n{\r\n    AddCalculationItemIfNotExists(\r\n        \"YTD\",\r\n        string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n\r\nVAR _LastDayAvailable = {0}\r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}),\r\n    {1} <= _LastDayAvailable\r\n    )\r\nVAR _Result = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESYTD(_CurrentDates)\r\n    )\r\n    \r\nRETURN \r\n    _Result\", _LastDateAvailable, _CalendarDate),\r\n        ordinal++, \"Accumulated year to date, hiding future dates after last available date\", null\r\n    );\r\n\r\n    AddCalculationItemIfNotExists(\r\n        \"LYTD\",\r\n        string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n\r\nVAR _LastDayAvailable = {0}\r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\nVAR _Result = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESYTD(SAMEPERIODLASTYEAR(_CurrentDates))\r\n    )\r\n    \r\nRETURN \r\n    _Result\", _LastDateAvailable, _CalendarDate),\r\n        ordinal++, \"Accumulated year to date last year, hiding future dates from last available date (same date last year)\", null\r\n    );\r\n\r\n    AddCalculationItemIfNotExists(\r\n        \"YOYTD\",\r\n        string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n\r\nVAR _LastDayAvailable = {0}\r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\nVAR _CurrentYear = \r\n     CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESYTD(_CurrentDates)\r\n     )\r\nVAR _PreviousYear = \r\n     CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESYTD(SAMEPERIODLASTYEAR(_CurrentDates))\r\n     )\r\n     \r\nRETURN \r\n    _CurrentYear - _PreviousYear\", _LastDateAvailable, _CalendarDate),\r\n        ordinal++, \"YOYTD = Year-to-Date Deviation, this year and last year accumulated\", null\r\n    );\r\n\r\n    AddCalculationItemIfNotExists(\r\n        \"YOYTD %\",\r\n        string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n\r\nVAR _LastDayAvailable = {0}\r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\nVAR _CurrentYear = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(),\r\n        DATESYTD(_CurrentDates)\r\n    )\r\nVAR _PreviousYear = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESYTD(SAMEPERIODLASTYEAR(_CurrentDates))\r\n    )\r\nVAR _DeltaYear = _CurrentYear - _PreviousYear\r\n\r\nRETURN \r\n    DIVIDE(_DeltaYear, _PreviousYear)\", _LastDateAvailable, _CalendarDate),\r\n        ordinal++, \"YOYTD = Year-to-Date Index %, % change this year vs last\", \"\\\"0%\\\"\"\r\n    );\r\n\r\n    AddCalculationItemIfNotExists(\r\n        \"YTD C\",\r\n        string.Format(@\"CALCULATE(\r\n        SELECTEDMEASURE(),\r\n        DATESYTD({0})\r\n        )\", _CalendarDate),\r\n        ordinal++, \"YTD C = Year-to-Date Complete, no future-date filtering\", null\r\n    );\r\n\r\n    AddCalculationItemIfNotExists(\r\n        \"LYTD C\",\r\n        string.Format(@\"CALCULATE(\r\n        SELECTEDMEASURE(),\r\n        DATESYTD(SAMEPERIODLASTYEAR({0}))\r\n        )\", _CalendarDate),\r\n        ordinal++, \"LYTD C = Last Year-to-Date Complete, no future-date filtering\", null\r\n    );\r\n\r\n    continue;\r\n}\r\n\r\n      if (item == \"R12\")\r\n    {\r\n        AddCalculationItemIfNotExists(\"Rolling 12M\", string.Format(@\"// Reference: https://www.sqlbi.com/articles/rolling-12-months-average-in-dax/\r\n\r\nVAR _LastDayShown = {0}\r\nVAR _NumOfMonths = 12\r\nVAR _ReferenceDate = \r\n    CALCULATE(\r\n        MAX({1}),\r\n        FILTER(VALUES({1}), \r\n        {1} <= _LastDayShown\r\n        )\r\n    )\r\nVAR _PreviousDates =\r\n    DATESINPERIOD({1}, _ReferenceDate, -_NumOfMonths, MONTH)\r\n\r\nVAR _Result =\r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        _PreviousDates\r\n    )\r\nVAR _firstDateInPeriod = MINX(_PreviousDates, {1})\r\nRETURN IF(_firstDateInPeriod <= _ReferenceDate, _Result)\", _LastDateAvailable, _CalendarDate), ordinal++, \"Rolling 12 months, hiding future dates after last available date\", null);\r\n        \r\nAddCalculationItemIfNotExists(\"Rolling 12M LY\", string.Format(@\"// Reference: https://www.sqlbi.com/articles/rolling-12-months-average-in-dax/\r\nVAR _LastDayShown = {0}\r\nVAR _NumOfMonths = 12\r\n\r\nVAR _ReferenceDate = \r\n    CALCULATE(\r\n        MAX({1}),\r\n        FILTER(VALUES({1}), \r\n        {1} <= _LastDayShown\r\n        )\r\n    )\r\n    \r\nVAR _PreviousDates =\r\n    DATESINPERIOD({1}, _ReferenceDate, -_NumOfMonths, MONTH)\r\n    \r\nVAR _Result =\r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        SAMEPERIODLASTYEAR(_PreviousDates)\r\n    )\r\nVAR _firstDateInPeriod = MINX(_PreviousDates, {1})\r\n\r\nRETURN \r\n    IF(_firstDateInPeriod <= _ReferenceDate, _Result)\", _LastDateAvailable, _CalendarDate), ordinal++, \"Rolling 12 months last year, hiding future dates\", null);\r\n       \r\nAddCalculationItemIfNotExists(\"Rolling 12M Dev\", string.Format(@\"// Reference: https://www.sqlbi.com/articles/rolling-12-months-average-in-dax/\r\nVAR _LastDayShown = {0}\r\nVAR _NumOfMonths = 12\r\nVAR _ReferenceDate = \r\n    CALCULATE(\r\n        MAX({1}),\r\n        FILTER(VALUES({1}), \r\n        {1} <= _LastDayShown\r\n        )\r\n    )\r\n    \r\nVAR _PreviousDates =\r\n    DATESINPERIOD({1}, _ReferenceDate, -_NumOfMonths, MONTH)\r\n    \r\nVAR _CurrentResult =\r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        _PreviousDates)\r\n        \r\nVAR _PreviousResult =\r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        SAMEPERIODLASTYEAR(_PreviousDates)\r\n    )\r\n    \r\nVAR _firstDateInPeriod = MINX(_PreviousDates, {1})\r\n\r\nRETURN \r\n    IF(_firstDateInPeriod <= _ReferenceDate, _CurrentResult - _PreviousResult)\", _LastDateAvailable, _CalendarDate), ordinal++, \"Rolling 12 months Deviation\", null);\r\n        \r\nAddCalculationItemIfNotExists(\"Rolling 12M idx\", string.Format(@\"// Reference: https://www.sqlbi.com/articles/rolling-12-months-average-in-dax/\r\nVAR _LastDayShown = {0}\r\nVAR _NumOfMonths = 12\r\nVAR _ReferenceDate = \r\n    CALCULATE(\r\n        MAX({1}),\r\n        FILTER(VALUES({1}), \r\n        {1} <= _LastDayShown\r\n        )\r\n    )\r\n    \r\nVAR _PreviousDates =\r\n    DATESINPERIOD({1}, _ReferenceDate, -_NumOfMonths, MONTH)\r\n\r\nVAR _CurrentResult =\r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        _PreviousDates\r\n    )\r\nVAR _PreviousResult =\r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        SAMEPERIODLASTYEAR(_PreviousDates)\r\n    )\r\n    \r\nVAR _DeviationResult = _CurrentResult - _PreviousResult\r\nVAR _firstDateInPeriod = MINX(_PreviousDates, {1})\r\n\r\nRETURN \r\n    IF(_firstDateInPeriod <= _ReferenceDate, DIVIDE(_DeviationResult, _PreviousResult))\", _LastDateAvailable, _CalendarDate), ordinal++, \"Rolling 12 months Index %\", \"\\\"0%\\\"\");\r\n        continue;\r\n    }\r\n    \r\n    \r\n    \r\n    if (item == \"Rolling average\")\r\n    {\r\n        if (!string.IsNullOrEmpty(_selectedAverage))\r\n        {\r\n            AddCalculationItemIfNotExists(\"Rolling 12M avg\", string.Format(@\"// Reference: https://www.sqlbi.com/articles/rolling-12-months-average-in-dax/\r\n\r\n //Calculating the average based on the selection in VALUES, such as per day or per month\r\n \r\nVAR _LastDayShown = {0}\r\n        \r\nVAR _NumOfMonths = 12\r\n// Hiding future days. If not remove the calculate in _ReferenceDate\r\nVAR  _LastCurrentDate = CALCULATE(\r\n    max({1}), FILTER(\r\n        VALUES( {1} ),\r\n        {1} <= _LastDayShown\r\n    )\r\n)\r\n\r\n VAR _Period =\r\n        DATESINPERIOD ( {1}, _LastCurrentDate, - _NumOfMonths, MONTH )  \r\n    \r\nVAR _Result =\r\n        CALCULATE (\r\n            AVERAGEX (\r\n                VALUES ( {2} ),     \r\n                SELECTEDMEASURE () \r\n            ),\r\n            _Period\r\n        ) \r\n    \r\n     VAR _firstDateInPeriod = MINX ( _Period, {1} )\r\n   \r\n    \r\nRETURN \r\n    IF ( _firstDateInPeriod <= _LastCurrentDate, _Result )\",\r\n    _LastDateAvailable, _CalendarDate, _selectedAverage),\r\n    ordinal++,\r\n    string.Format(\"Rolling 12 months average per {0}, hiding future dates\", _selectedAverage),\r\n    null);\r\n        }\r\n        continue;\r\n    }\r\n    \r\n        if (item == \"Rolling total\")\r\n        {     \r\n    AddCalculationItemIfNotExists(\"Rolling Total\", string.Format(@\"\r\nvar _currdate= {0}\r\n\r\nRETURN\r\n    CALCULATE(\r\n        SELECTEDMEASURE(),\r\n        FILTER(\r\n            ALLSELECTED({1}),\r\n            ISONORAFTER({1}, _currdate, DESC)\r\n        )\r\n    )\r\n\r\n     \"\r\n        , _LastDateAvailable, _CalendarDate), ordinal++,\r\n        \"Running Total, from the first date available until selected date\", null);\r\n        continue;\r\n    }\r\n    \r\n    \r\n\r\n    \r\n    // Placeholder: additional Time Intelligence logic goes here\r\n  //  AddCalculationItemIfNotExists(item, \"SELECTEDMEASURE()\", ordinal++, \"Time Intelligence - \" + item, null);\r\n}\r\n\r\nif (skippedItems.Count > 0)\r\n{\r\nstring message = \"The following calculation item(s) were skipped because they already exist:\\n\\n\" + string.Join(\"\\n\", skippedItems);\r\n\r\n    MessageBox.Show(message, \"Items Skipped\", MessageBoxButtons.OK, MessageBoxIcon.Information);\r\n}\r\n\r\n\r\n",
      "Tooltip": "For a calculation group that is created, adds calculation items based on selection. Input to definitions by variables. If it is a \"New calculation group\", it sets the name and precedence to 0",
      "ValidContexts": "CalculationGroupTable"
    },
    {
      "Name": "3. Calculation Groups and FP\\3. Create Field Parameter",
      "Enabled": "true",
      "Execute": "\r\n// This is a script copied from Tabular Editor homepage: https://docs.tabulareditor.com/common/CSharpScripts/Beginner/script-create-field-parameter.html\r\n\r\n\r\n// Before running the script, select the measures or columns that you\r\n// would like to use as field parameters (hold down CTRL to select multiple\r\n// objects). Also, you may change the name of the field parameter table\r\n// below. NOTE: If used against Power BI Desktop, you must enable unsupported\r\n// features under File > Preferences (TE2) or Tools > Preferences (TE3).\r\nvar name = \"FP - NewParameter\";\r\n\r\nif(Selected.Columns.Count == 0 && Selected.Measures.Count == 0) throw new Exception(\"No columns or measures selected!\");\r\n\r\n// Construct the DAX for the calculated table based on the current selection:\r\nvar objects = Selected.Columns.Any() ? Selected.Columns.Cast<ITabularTableObject>() : Selected.Measures;\r\n//Without column pre-fix\r\nvar dax = \"{\\n    \" + string.Join(\",\\n    \", objects.Select((c,i) => string.Format(\"(\\\"{0}\\\", NAMEOF('{1}'[{0}]), {2})\", c.Name, c.Table.Name, i))) + \"\\n}\";\r\n//with column pre-fix, use this: \r\n//var dax = \"{\\n    \" + string.Join(\",\\n    \", objects.Select((c,i) => string.Format(\"(\\\"{0}\\\", NAMEOF('{1}'[{0}]), {2})\", c.Name, c.Table.Name, i))) + \"\\n}\";\r\n\r\n// Add the calculated table to the model:\r\nvar table = Model.AddCalculatedTable(name, dax);\r\n    table.Description = \"Selected field parameter\";\r\n\r\n// In TE2 columns are not created automatically from a DAX expression, so \r\n// we will have to add them manually:\r\nvar te2 = table.Columns.Count == 0;\r\nvar nameColumn = te2 ? table.AddCalculatedTableColumn(name, \"[Value1]\") : table.Columns[\"Value1\"] as CalculatedTableColumn;\r\nvar fieldColumn = te2 ? table.AddCalculatedTableColumn(name + \" Fields\", \"[Value2]\") : table.Columns[\"Value2\"] as CalculatedTableColumn;\r\nvar orderColumn = te2 ? table.AddCalculatedTableColumn(name + \" Order\", \"[Value3]\") : table.Columns[\"Value3\"] as CalculatedTableColumn;\r\n\r\nif(!te2) {\r\n    // Rename the columns that were added automatically in TE3:\r\n    nameColumn.IsNameInferred = false;\r\n    nameColumn.Name = name;\r\n    nameColumn.Description = \"Selected field\";\r\n    fieldColumn.IsNameInferred = false;\r\n    fieldColumn.Name = name + \" Fields\";\r\n    orderColumn.IsNameInferred = false;\r\n    orderColumn.Name = name + \" Order\";\r\n    orderColumn.Description = \"Order of the fields\";\r\n}\r\n// Set remaining properties for field parameters to work\r\n// See: https://twitter.com/markbdi/status/1526558841172893696\r\nnameColumn.SortByColumn = orderColumn;\r\nnameColumn.GroupByColumns.Add(fieldColumn);\r\nfieldColumn.SortByColumn = orderColumn;\r\nfieldColumn.SetExtendedProperty(\"ParameterMetadata\", \"{\\\"version\\\":3,\\\"kind\\\":2}\", ExtendedPropertyType.Json);\r\nfieldColumn.IsHidden = true;\r\norderColumn.IsHidden = true;",
      "Tooltip": "Requires allow unsupported features",
      "ValidContexts": "Model"
    },
    {
      "Name": "3. Calculation Groups and FP\\3. Create or add to Time Intelligence Calculation group",
      "Enabled": "true",
      "Execute": "\r\n// This script includes the select time calculations that are to be included. The idea is from the following script, but here it is included as a Calculation Group instead and with some modifications\r\n//        Data-Goblin inspiration: https://github.com/data-goblin/powerbi-macguyver-toolbox/blob/main/tabular-editor-scripts/csharp-scripts/add-dax-templates/add-time-intelligence.csx\r\n\r\n\r\n// There are some input that are dynamically included in the generation of time intelligence calculations:\r\n//     1. Date column to be used from the date table (needs to be created first)\r\n//     2. Measure that shows the last data from calendar or transaction (needs to be calculated first and have the correct formatString containing \"yy\"). The purpose is to hide future dates in calculations, where applicable\r\n//     3. Based on the selected Time intelligence calculations, it is logic on which input is required. \r\n\r\n// Naming is aiming at following this pattern: https://www.daxpatterns.com/standard-time-related-calculations/\r\n// Referance to source for the expressions are included in the measure expressions\r\n\r\n// If you know of some measures with % format, this can be updated in the logic for the calculation item before running the script\r\n\r\n\r\n#r \"System.Drawing\"\r\nusing System.Windows.Forms;\r\nusing System.Drawing;\r\nusing System.Linq;\r\nusing System.Collections.Generic;\r\n\r\n// Don't show the script execution dialog or cursor\r\nScriptHelper.WaitFormVisible = false;\r\nApplication.UseWaitCursor = false;\r\n\r\n\r\n// ─────────────────────────────────────────────────────────────\r\n// Rename Calculation Group Table and Column if it's a new one\r\n\r\n// Define inline input dialog function \r\nFunc<string, string, string, string> ShowInputDialog = (text, caption, defaultValue) =>\r\n{\r\n    Form prompt = new Form()\r\n    {\r\n        Width = 600,\r\n        Height = 150,\r\n        FormBorderStyle = FormBorderStyle.FixedDialog,\r\n        Text = caption,\r\n        StartPosition = FormStartPosition.CenterScreen\r\n    };\r\n    Label textLabel = new Label() { Left = 50, Top = 20, Text = text, AutoSize = true };\r\n    TextBox textBox = new TextBox() { Left = 50, Top = 50, Width = 500, Text = defaultValue };\r\n    Button confirmation = new Button() { Text = \"OK\", Left = 450, Width = 100, Top = 70, DialogResult = DialogResult.OK };\r\n    confirmation.Click += (sender, e) => { prompt.Close(); };\r\n    prompt.Controls.Add(textLabel);\r\n    prompt.Controls.Add(textBox);\r\n    prompt.Controls.Add(confirmation);\r\n    prompt.AcceptButton = confirmation;\r\n\r\n    return prompt.ShowDialog() == DialogResult.OK ? textBox.Text : \"\";\r\n};\r\n\r\n// Declare table and column variables\r\nstring _timeIntelligenceCalcGroupTable = string.Empty;\r\nstring _timeIntelligenceCalcGroupColumn = string.Empty;\r\n\r\n// Get all Calculation Groups from the model\r\nvar calcGroups = Model.CalculationGroups.ToList();\r\n\r\n// Declare Calculation Group Table\r\nCalculationGroupTable cgTable = null;\r\n\r\nif (calcGroups.Count > 0)\r\n{\r\n    // Ask user if they want to use an existing calculation group\r\n    DialogResult dialogResult = MessageBox.Show(\"Do you want to add to an existing calculation group?\", \"Select calculation group\", MessageBoxButtons.YesNo);\r\n\r\n    if (dialogResult == DialogResult.Yes)\r\n    {\r\n        // Get all non-ordinal columns from all calc groups\r\n        var nonOrdinalColumns = calcGroups\r\n            .SelectMany(cg => cg.Columns.Where(c => c.Name != \"Ordinal\"))\r\n            .ToList();\r\n\r\n        if (nonOrdinalColumns.Count == 0)\r\n        {\r\n            MessageBox.Show(\"No valid Calculation Group columns found.\", \"Error\", MessageBoxButtons.OK, MessageBoxIcon.Error);\r\n            return;\r\n        }\r\n\r\n        // Select the column\r\n        var selectedCol = SelectColumn(nonOrdinalColumns, null, \"Select Time Intelligence calc group column\");\r\n        if (selectedCol == null) return;\r\n\r\n        _timeIntelligenceCalcGroupTable = selectedCol.Table.Name;\r\n        _timeIntelligenceCalcGroupColumn = selectedCol.Name;\r\n\r\n        // Get the selected Calculation Group Table\r\n        cgTable = Model.Tables[_timeIntelligenceCalcGroupTable] as CalculationGroupTable;\r\n    }\r\n}\r\n\r\nif (cgTable == null) // If user selected \"No\" or no calc groups exist\r\n{\r\n    string defaultTableName = \"Time Intelligence\";\r\n    string defaultColumnName = \"Time Calculation\";\r\n\r\n _timeIntelligenceCalcGroupTable = ShowInputDialog(\"TABLE NAME CALCULATION GROUP:\", \"Calculation Group name\", defaultTableName);\r\n_timeIntelligenceCalcGroupColumn = ShowInputDialog(\"COLUMN NAME CALCULATION GROUP:\", \"Column name\", defaultColumnName);\r\n\r\n\r\n    // Create a new Calculation Group Table\r\n    cgTable = Model.AddCalculationGroup(_timeIntelligenceCalcGroupTable);\r\n\r\n    if (cgTable != null)\r\n    {\r\n        //(cgTable.Columns[\"Name\"] as DataColumn).Name = _timeIntelligenceCalcGroupColumn;\r\n        var nameColumn = cgTable.Columns[\"Name\"] as TabularEditor.TOMWrapper.DataColumn;\r\nif (nameColumn != null)\r\n    nameColumn.Name = _timeIntelligenceCalcGroupColumn;\r\n\r\n        var renamedColumn = cgTable.Columns[_timeIntelligenceCalcGroupColumn] as TabularEditor.TOMWrapper.DataColumn;\r\n\r\nif (renamedColumn != null)\r\n    renamedColumn.Description = \"The selected time intelligence\";\r\n\r\n        cgTable.Description = \"Calculation group for dynamic time intelligence.\";\r\n        cgTable.CalculationGroup.Precedence = 0;\r\n    }\r\n    else\r\n    {\r\n        MessageBox.Show(\"Failed to create Calculation Group Table.\", \"Error\", MessageBoxButtons.OK, MessageBoxIcon.Error);\r\n        return;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n// ─────────────────────────────────────────────────────────────\r\n// Helper: Column selector\r\nFunc<IEnumerable<Column>, string, Column> SelectColumnFromList = (columns, title) =>\r\n{\r\n    var form = new Form();\r\n    var listBox = new ListBox();\r\n    var okButton = new Button();\r\n    var cancelButton = new Button();\r\n    var label = new Label();\r\n\r\n    form.Text = \"Select Column\"; // Keep title short (multiline not supported)\r\n    form.Width = 400;\r\n    form.Height = 470;\r\n    form.FormBorderStyle = FormBorderStyle.FixedDialog;\r\n    form.StartPosition = FormStartPosition.CenterScreen;\r\n\r\n    label.Text = title;  // Use the existing title input as label text\r\n    label.Left = 10;\r\n    label.Top = 10;\r\n    label.Width = 360;\r\n    label.Height = 40;\r\n    label.AutoSize = false;\r\n\r\n    listBox.Width = 360;\r\n    listBox.Height = 280;\r\n    listBox.Left = 10;\r\n    listBox.Top = 60;\r\n    listBox.SelectionMode = SelectionMode.One;\r\n    listBox.DataSource = columns.Select(c => c.DaxObjectFullName).ToList();\r\n\r\n    okButton.Text = \"OK\";\r\n    okButton.Left = 220;\r\n    okButton.Top = 360;\r\n    okButton.DialogResult = DialogResult.OK;\r\n\r\n    cancelButton.Text = \"Cancel\";\r\n    cancelButton.Left = 300;\r\n    cancelButton.Top = 360;\r\n    cancelButton.DialogResult = DialogResult.Cancel;\r\n\r\n    form.Controls.Add(label);\r\n    form.Controls.Add(listBox);\r\n    form.Controls.Add(okButton);\r\n    form.Controls.Add(cancelButton);\r\n    form.AcceptButton = okButton;\r\n    form.CancelButton = cancelButton;\r\n\r\n    var result = form.ShowDialog();\r\n    if (result == DialogResult.OK && listBox.SelectedIndex >= 0)\r\n    {\r\n        string selectedName = listBox.SelectedItem.ToString();\r\n        return columns.FirstOrDefault(c => c.DaxObjectFullName == selectedName);\r\n    }\r\n    return null;\r\n};\r\n\r\n\r\n// ─────────────────────────────────────────────────────────────\r\n// Helper: Measure selector\r\nFunc<IEnumerable<Measure>, string, Measure> SelectMeasureFromList = (measures, title) =>\r\n{\r\n    var form = new Form();\r\n    var listBox = new ListBox();\r\n    var okButton = new Button();\r\n    var cancelButton = new Button();\r\n    var label = new Label();\r\n\r\n    form.Text = \"Select Measure\"; // Keep title short\r\n    form.Width = 400;\r\n    form.Height = 470;\r\n    form.FormBorderStyle = FormBorderStyle.FixedDialog;\r\n    form.StartPosition = FormStartPosition.CenterScreen;\r\n\r\n    label.Text = title;  // Use the existing title input as label text\r\n    label.Left = 10;\r\n    label.Top = 10;\r\n    label.Width = 360;\r\n    label.Height = 40;\r\n    label.AutoSize = false;\r\n\r\n    listBox.Width = 360;\r\n    listBox.Height = 280;\r\n    listBox.Left = 10;\r\n    listBox.Top = 60;\r\n    listBox.SelectionMode = SelectionMode.One;\r\n    listBox.DataSource = measures.Select(m => m.DaxObjectFullName).ToList();\r\n\r\n    okButton.Text = \"OK\";\r\n    okButton.Left = 220;\r\n    okButton.Top = 360;\r\n    okButton.DialogResult = DialogResult.OK;\r\n\r\n    cancelButton.Text = \"Cancel\";\r\n    cancelButton.Left = 300;\r\n    cancelButton.Top = 360;\r\n    cancelButton.DialogResult = DialogResult.Cancel;\r\n\r\n    form.Controls.Add(label);\r\n    form.Controls.Add(listBox);\r\n    form.Controls.Add(okButton);\r\n    form.Controls.Add(cancelButton);\r\n    form.AcceptButton = okButton;\r\n    form.CancelButton = cancelButton;\r\n\r\n    var result = form.ShowDialog();\r\n    if (result == DialogResult.OK && listBox.SelectedIndex >= 0)\r\n    {\r\n        string selectedName = listBox.SelectedItem.ToString();\r\n        return measures.FirstOrDefault(m => m.DaxObjectFullName == selectedName);\r\n    }\r\n    return null;\r\n};\r\n\r\n// ─────────────────────────────────────────────────────────────\r\n// Time Intelligence Selection UI\r\n\r\nstring[] calcTypes = new string[] {\r\n    \"Actual\", \"MTD\", \"QTD\", \"YTD\", \"R12\", \"Rolling average\", \"Rolling total\"\r\n};\r\n\r\nForm tiForm = new Form();\r\nListBox tiListBox = new ListBox();\r\nButton tiButton = new Button();\r\nLabel tiLabel = new Label();\r\n\r\ntiForm.Text = \"Select Time Intelligence Types\";\r\ntiForm.Width = 350;\r\ntiForm.Height = 400;\r\n\r\ntiLabel.Text = \"Select one or more calculation types:\";\r\ntiLabel.Location = new Point(20, 10);\r\ntiLabel.Width = 300;\r\n\r\ntiListBox.Items.AddRange(calcTypes);\r\ntiListBox.SelectionMode = SelectionMode.MultiExtended;\r\ntiListBox.Location = new Point(20, 40);\r\ntiListBox.Width = 290;\r\ntiListBox.Height = 250;\r\n\r\ntiButton.Text = \"OK\";\r\ntiButton.Location = new Point(120, 310);\r\ntiButton.Width = 100;\r\ntiButton.Click += (sender, e) => { tiForm.Close(); };\r\n\r\ntiForm.Controls.Add(tiListBox);\r\ntiForm.Controls.Add(tiButton);\r\ntiForm.Controls.Add(tiLabel);\r\ntiForm.ShowDialog();\r\n\r\nList<string> selectedValues = tiListBox.SelectedItems.Cast<string>().ToList();\r\n\r\n\r\n\r\n\r\nvar _dateColumns = Model.AllColumns.Where(c => c.DataType == DataType.DateTime &&\r\n    c.IsKey == true).ToList();\r\n    var selectedDateCol = SelectColumnFromList(\r\n    _dateColumns,\r\n    \"Select the DATE column for time calculations.\\n\\nA Date table marked as a date table is required.\"\r\n);\r\n\r\nif (selectedDateCol == null) return;\r\nstring _CalendarDate = selectedDateCol.DaxObjectFullName;\r\nvar _calendarTableName = _CalendarDate.Split('[')[0].Trim('\\'');\r\n\r\nstring _LastDateAvailable = null;\r\n\r\nbool requiresFutureDateLogic = selectedValues.Any(x => new[] { \"Actual\", \"MTD\", \"QTD\", \"YTD\", \"R12\", \"Rolling average\", \"Rolling total\" }.Contains(x));\r\nif (requiresFutureDateLogic)\r\n{\r\n    var _dateFormattedMeasures = Model.AllMeasures\r\n        .Where(m => m.FormatString != null && (m.FormatString.Contains(\"yy\") || m.FormatString.Contains(\"yyyy\")))\r\n        .ToList();\r\n\r\n        var selectedMeasure = SelectMeasureFromList(_dateFormattedMeasures, \"Select MEASURE for hiding future dates \\n\\n (Cancel will create logic for last date)\");\r\n    _LastDateAvailable = selectedMeasure != null\r\n        ? selectedMeasure.DaxObjectName\r\n        : string.Format(\"MIN(MAX({0}), TODAY())\", _CalendarDate);\r\n}\r\n\r\nstring _selectedAverage = null;\r\nif (selectedValues.Contains(\"Rolling average\"))\r\n{\r\n    var _selectedTableName = _CalendarDate.Split('[')[0].Trim('\\'');\r\n    var _selectedDateTable = Model.Tables[_selectedTableName];\r\n    var _columnsInDateTable = _selectedDateTable.Columns.ToList();\r\n\r\n    var avgCol = SelectColumnFromList(_columnsInDateTable, \"Select column for Rolling 12M Average \\n\\n(e.g., daily/monthly)\");\r\n    if (avgCol != null)\r\n    {\r\n        _selectedAverage = avgCol.DaxObjectFullName;\r\n    }\r\n}\r\n\r\n// Optional debug\r\n//string debugMsg = \"Selected: \" + string.Join(\", \", selectedValues);\r\n//debugMsg += \"\\nCalendar Date: \" + _CalendarDate;\r\n//debugMsg += _LastDateAvailable != null ? \"\\nLast Date Logic: \" + _LastDateAvailable : \"\";\r\n//debugMsg += _selectedAverage != null ? \"\\nRolling Average Column: \" + _selectedAverage : \"\";\r\n//MessageBox.Show(debugMsg);\r\n\r\n// Set starting ordinal\r\nint ordinal = cgTable.Name.StartsWith(\"New Calculation Group\") ? 0 :\r\n    (cgTable.CalculationItems.Count > 0 ? cgTable.CalculationItems.Max(ci => ci.Ordinal) + 1 : 0);\r\n        \r\n\r\n\r\n// ─────────────────────────────────────────────────────────────\r\n// AddCalculationItemIfNotExists helper\r\n\r\nList<string> skippedItems = new List<string>();\r\n\r\nAction<string, string, int, string, string> AddCalculationItemIfNotExists = \r\n(name, expression, ordinalPos, description, formatString) =>\r\n{\r\nif (cgTable.CalculationItems.Any(ci => ci.Name.Equals(name, System.StringComparison.OrdinalIgnoreCase)))\r\n{\r\n    skippedItems.Add(name);\r\n    return;\r\n}\r\n\r\n\r\n    var item = cgTable.AddCalculationItem(name);\r\n    item.Expression = expression;\r\n    item.Ordinal = ordinalPos;\r\n    item.Description = description;\r\n    // FormatDax(item);\r\n};\r\n\r\n\r\n// ─────────────────────────────────────────────────────────────\r\n// Looping through all selected calculation item categories\r\nforeach (var item in selectedValues)\r\n{\r\n\r\n    if (item == \"Actual\")\r\n    {\r\n        AddCalculationItemIfNotExists(\"Actual\", \"SELECTEDMEASURE()\", ordinal++, \"Actual values\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"Actual to date\", string.Format(@\"\r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\n    \r\nRETURN \r\n    CALCULATE(\r\n        SELECTEDMEASURE(),\r\n        _CurrentDates\r\n    )\", _LastDateAvailable, _CalendarDate), ordinal++, \"Actual value until last date available\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"Actual Y-1\", \r\n    string.Format(\r\n        \"CALCULATE(\\n\" +\r\n        \"    SELECTEDMEASURE(),\\n\" +\r\n        \"    SAMEPERIODLASTYEAR({0})\\n\" +\r\n        \")\", \r\n        _CalendarDate\r\n    ), \r\n    ordinal++, \"Actual value last year\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"Actual to date Y-1\", string.Format(@\"\r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\n    \r\nRETURN \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        SAMEPERIODLASTYEAR(_CurrentDates)\r\n    )\", \r\n_LastDateAvailable, \r\n_CalendarDate), ordinal++, \"Actual value last year, hiding future dates as of this year\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"AOA\", string.Format(@\"\r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\nVAR _thisyear = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(),\r\n        _CurrentDates\r\n    )\r\nVAR _lastyear = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        SAMEPERIODLASTYEAR(_CurrentDates)\r\n    )\r\n    \r\nRETURN \r\n    _thisyear - _lastyear\", _LastDateAvailable, _CalendarDate), ordinal++, \"AOA = Actual over Actual: Deviation for actual value this year and last year, hiding future dates\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"AOA %\", string.Format(@\"\r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\nVAR _thisyear = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        _CurrentDates\r\n        )\r\nVAR _lastyear = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        SAMEPERIODLASTYEAR(_CurrentDates)\r\n    )\r\nVAR _deviationYear = _thisyear - _lastyear\r\n\r\nRETURN \r\n    DIVIDE(_deviationYear, _lastyear)\", _LastDateAvailable, _CalendarDate), ordinal++, \"AOA %: Percentage change this year and last year, hiding future dates\", \"\\\"0%\\\"\");\r\n\r\n        AddCalculationItemIfNotExists(\"AOA C\", string.Format(@\"\r\nVAR _thisyear = SELECTEDMEASURE()\r\nVAR _lastyear = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        SAMEPERIODLASTYEAR({0})\r\n    )\r\n    \r\nRETURN \r\n    _thisyear - _lastyear\", _CalendarDate), ordinal++, \"AOA C = Complete Actual over Actual, not hiding future dates\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"AOA C %\", string.Format(@\"\r\nVAR _thisyear = SELECTEDMEASURE()\r\nVAR _lastyear = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        SAMEPERIODLASTYEAR({0})\r\n    )\r\nVAR _deviationYear = _thisyear - _lastyear\r\n\r\nRETURN \r\n    DIVIDE(_deviationYear, _lastyear)\", _CalendarDate), ordinal++, \"AOA C %: Complete Actual over Actual % change, not hiding future dates\", \"\\\"0%\\\"\");\r\n\r\n        continue;\r\n    }\r\n\r\n        // MTD logic\r\n    if (item == \"MTD\")\r\n    {\r\n        AddCalculationItemIfNotExists(\"MTD\", string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n\r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\n    \r\nRETURN \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESMTD(_CurrentDates)\r\n    )\", _LastDateAvailable, _CalendarDate), ordinal++, \"Accumulated Month to date, hiding future dates after last available date\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"MTD LY\", string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n        \r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\n    \r\nRETURN \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESMTD(SAMEPERIODLASTYEAR(_CurrentDates))\r\n    )\", _LastDateAvailable, _CalendarDate), ordinal++, \"Accumulated Month to date last year, hiding future dates from last available date (same date last year)\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"MOMTD\", string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n        \r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\nVAR _CurrentMonth = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESMTD(_CurrentDates)\r\n    )\r\nVAR _PreviousMonth = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESMTD(SAMEPERIODLASTYEAR(_CurrentDates))\r\n    )\r\n    \r\nRETURN \r\n    _CurrentMonth - _PreviousMonth\", _LastDateAvailable, _CalendarDate), ordinal++, \"MOMTD = Month over Month to date: Month-to-Date Deviation, this year and last year accumulated\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"MOMTD %\", string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n        \r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\nVAR _CurrentMonth = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESMTD(_CurrentDates)\r\n    )\r\nVAR _PreviousMonth = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESMTD(SAMEPERIODLASTYEAR(_CurrentDates))\r\n    )\r\nVAR _DeltaMonth = _CurrentMonth - _PreviousMonth\r\n\r\nRETURN \r\n    DIVIDE(_DeltaMonth, _PreviousMonth)\", _LastDateAvailable, _CalendarDate), ordinal++, \"MOMTD = Month over Month to date %: % change this year compared to last year accumulated\", \"\\\"0%\\\"\");\r\n\r\n        AddCalculationItemIfNotExists(\"MTD PM\", string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n\r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\n    \r\nRETURN \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESMTD(PREVIOUSMONTH(_CurrentDates))\r\n    )\", _LastDateAvailable, _CalendarDate), ordinal++, \"Accumulated Month to date previous Month, hiding future dates from last available date (same date last Month)\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"MTD PQ\", string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n        \r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\n    \r\nRETURN \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESMTD(PREVIOUSQUARTER(_CurrentDates))\r\n    )\", _LastDateAvailable, _CalendarDate), ordinal++, \"Accumulated Month to date previous Quarter, hiding future dates from last available date (same date last quarter)\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"MTD C\", string.Format(@\"CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESMTD({0})\r\n        )\"\r\n        , _CalendarDate), ordinal++, \"MTD C = Month to date Complete: accumulated, without hiding of future dates\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"MTD LY C\", string.Format(@\"CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESMTD(SAMEPERIODLASTYEAR({0}))\r\n        )\", \r\n        _CalendarDate), ordinal++, \"MTD LY C = Month to date Complete Last Year: Month last year accumulated, without hiding future dates\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"MTD PM C\", string.Format(@\"CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESMTD(PREVIOUSMONTH({0}))\r\n        )\", _CalendarDate), ordinal++, \"MTD PM C = Month to date, Previous month, Complete: Last Month previous month accumulated, without hiding future dates\", null);\r\n\r\n        continue;\r\n    }\r\n    \r\n // QTD logic\r\n    if (item == \"QTD\")\r\n    {\r\n        AddCalculationItemIfNotExists(\"QTD\", string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n        \r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\n    \r\nRETURN \r\n    \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESQTD(_CurrentDates)\r\n    )\", _LastDateAvailable, _CalendarDate), ordinal++, \"Accumulated quarter to date, hiding future dates after last available date\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"QTD LY\", string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n        \r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\n\r\nRETURN \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESQTD(SAMEPERIODLASTYEAR(_CurrentDates))\r\n    )\", _LastDateAvailable, _CalendarDate), ordinal++, \"Accumulated quarter to date last year, hiding future dates from last available date (same date last year)\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"QOQTD\", string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n      \r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\nVAR _CurrentYear = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESQTD(_CurrentDates)\r\n     )\r\nVAR _PreviousYear = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESQTD(SAMEPERIODLASTYEAR(_CurrentDates))\r\n    )\r\n\r\nRETURN \r\n    _CurrentYear - _PreviousYear\", _LastDateAvailable, _CalendarDate), ordinal++, \"QOQTD = Quarter over Quarter to date: Quarter-to-Date Deviation, this year and last year accumulated\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"QOQTD %\", string.Format(@\"\r\n// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n\r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\nVAR _CurrentYear = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESQTD(_CurrentDates)\r\n    )\r\nVAR _PreviousYear = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESQTD(SAMEPERIODLASTYEAR(_CurrentDates))\r\n    )\r\nVAR _DeltaYear = _CurrentYear - _PreviousYear\r\n\r\nRETURN \r\n    DIVIDE(_DeltaYear, _PreviousYear)\", _LastDateAvailable, _CalendarDate), ordinal++, \"QOQTD = Quarter over Quarter to date: Quarter-to-Date Index, % change this year compared to last year accumulated\", \"\\\"0%\\\"\");\r\n\r\n        AddCalculationItemIfNotExists(\"QTD C\", string.Format(@\"CALCULATE(\r\n     SELECTEDMEASURE(), \r\n     DATESQTD({0})\r\n     )\", _CalendarDate), ordinal++, \"QTD C = Quarter to date Complete: Quarter to date accumulated, without hiding future dates\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"QTD LY C\", string.Format(@\"CALCULATE(\r\n    SELECTEDMEASURE(), \r\n    DATESQTD(SAMEPERIODLASTYEAR({0}))\r\n    )\", _CalendarDate), ordinal++, \"QTD LY C = Quarter to date last year Complete: Last Quarter accumulated, without hiding future dates\", null);\r\n\r\n        continue;\r\n    }\r\n\r\n// YTD logic\r\nif (item == \"YTD\")\r\n{\r\n    AddCalculationItemIfNotExists(\r\n        \"YTD\",\r\n        string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n\r\nVAR _LastDayAvailable = {0}\r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}),\r\n    {1} <= _LastDayAvailable\r\n    )\r\nVAR _Result = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESYTD(_CurrentDates)\r\n    )\r\n    \r\nRETURN \r\n    _Result\", _LastDateAvailable, _CalendarDate),\r\n        ordinal++, \"Accumulated year to date, hiding future dates after last available date\", null\r\n    );\r\n\r\n    AddCalculationItemIfNotExists(\r\n        \"LYTD\",\r\n        string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n\r\nVAR _LastDayAvailable = {0}\r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\nVAR _Result = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESYTD(SAMEPERIODLASTYEAR(_CurrentDates))\r\n    )\r\n    \r\nRETURN \r\n    _Result\", _LastDateAvailable, _CalendarDate),\r\n        ordinal++, \"Accumulated year to date last year, hiding future dates from last available date (same date last year)\", null\r\n    );\r\n\r\n    AddCalculationItemIfNotExists(\r\n        \"YOYTD\",\r\n        string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n\r\nVAR _LastDayAvailable = {0}\r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\nVAR _CurrentYear = \r\n     CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESYTD(_CurrentDates)\r\n     )\r\nVAR _PreviousYear = \r\n     CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESYTD(SAMEPERIODLASTYEAR(_CurrentDates))\r\n     )\r\n     \r\nRETURN \r\n    _CurrentYear - _PreviousYear\", _LastDateAvailable, _CalendarDate),\r\n        ordinal++, \"YOYTD = Year-to-Date Deviation, this year and last year accumulated\", null\r\n    );\r\n\r\n    AddCalculationItemIfNotExists(\r\n        \"YOYTD %\",\r\n        string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n\r\nVAR _LastDayAvailable = {0}\r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\nVAR _CurrentYear = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(),\r\n        DATESYTD(_CurrentDates)\r\n    )\r\nVAR _PreviousYear = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESYTD(SAMEPERIODLASTYEAR(_CurrentDates))\r\n    )\r\nVAR _DeltaYear = _CurrentYear - _PreviousYear\r\n\r\nRETURN \r\n    DIVIDE(_DeltaYear, _PreviousYear)\", _LastDateAvailable, _CalendarDate),\r\n        ordinal++, \"YOYTD = Year-to-Date Index %, % change this year vs last\", \"\\\"0%\\\"\"\r\n    );\r\n\r\n    AddCalculationItemIfNotExists(\r\n        \"YTD C\",\r\n        string.Format(@\"CALCULATE(\r\n        SELECTEDMEASURE(),\r\n        DATESYTD({0})\r\n        )\", _CalendarDate),\r\n        ordinal++, \"YTD C = Year-to-Date Complete, no future-date filtering\", null\r\n    );\r\n\r\n    AddCalculationItemIfNotExists(\r\n        \"LYTD C\",\r\n        string.Format(@\"CALCULATE(\r\n        SELECTEDMEASURE(),\r\n        DATESYTD(SAMEPERIODLASTYEAR({0}))\r\n        )\", _CalendarDate),\r\n        ordinal++, \"LYTD C = Last Year-to-Date Complete, no future-date filtering\", null\r\n    );\r\n\r\n    continue;\r\n}\r\n\r\n      if (item == \"R12\")\r\n    {\r\n        AddCalculationItemIfNotExists(\"Rolling 12M\", string.Format(@\"// Reference: https://www.sqlbi.com/articles/rolling-12-months-average-in-dax/\r\n\r\nVAR _LastDayShown = {0}\r\nVAR _NumOfMonths = 12\r\nVAR _ReferenceDate = \r\n    CALCULATE(\r\n        MAX({1}),\r\n        FILTER(VALUES({1}), \r\n        {1} <= _LastDayShown\r\n        )\r\n    )\r\nVAR _PreviousDates =\r\n    DATESINPERIOD({1}, _ReferenceDate, -_NumOfMonths, MONTH)\r\n\r\nVAR _Result =\r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        _PreviousDates\r\n    )\r\nVAR _firstDateInPeriod = MINX(_PreviousDates, {1})\r\nRETURN IF(_firstDateInPeriod <= _ReferenceDate, _Result)\", _LastDateAvailable, _CalendarDate), ordinal++, \"Rolling 12 months, hiding future dates after last available date\", null);\r\n        \r\nAddCalculationItemIfNotExists(\"Rolling 12M LY\", string.Format(@\"// Reference: https://www.sqlbi.com/articles/rolling-12-months-average-in-dax/\r\nVAR _LastDayShown = {0}\r\nVAR _NumOfMonths = 12\r\n\r\nVAR _ReferenceDate = \r\n    CALCULATE(\r\n        MAX({1}),\r\n        FILTER(VALUES({1}), \r\n        {1} <= _LastDayShown\r\n        )\r\n    )\r\n    \r\nVAR _PreviousDates =\r\n    DATESINPERIOD({1}, _ReferenceDate, -_NumOfMonths, MONTH)\r\n    \r\nVAR _Result =\r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        SAMEPERIODLASTYEAR(_PreviousDates)\r\n    )\r\nVAR _firstDateInPeriod = MINX(_PreviousDates, {1})\r\n\r\nRETURN \r\n    IF(_firstDateInPeriod <= _ReferenceDate, _Result)\", _LastDateAvailable, _CalendarDate), ordinal++, \"Rolling 12 months last year, hiding future dates\", null);\r\n       \r\nAddCalculationItemIfNotExists(\"Rolling 12M Dev\", string.Format(@\"// Reference: https://www.sqlbi.com/articles/rolling-12-months-average-in-dax/\r\nVAR _LastDayShown = {0}\r\nVAR _NumOfMonths = 12\r\nVAR _ReferenceDate = \r\n    CALCULATE(\r\n        MAX({1}),\r\n        FILTER(VALUES({1}), \r\n        {1} <= _LastDayShown\r\n        )\r\n    )\r\n    \r\nVAR _PreviousDates =\r\n    DATESINPERIOD({1}, _ReferenceDate, -_NumOfMonths, MONTH)\r\n    \r\nVAR _CurrentResult =\r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        _PreviousDates)\r\n        \r\nVAR _PreviousResult =\r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        SAMEPERIODLASTYEAR(_PreviousDates)\r\n    )\r\n    \r\nVAR _firstDateInPeriod = MINX(_PreviousDates, {1})\r\n\r\nRETURN \r\n    IF(_firstDateInPeriod <= _ReferenceDate, _CurrentResult - _PreviousResult)\", _LastDateAvailable, _CalendarDate), ordinal++, \"Rolling 12 months Deviation\", null);\r\n        \r\nAddCalculationItemIfNotExists(\"Rolling 12M idx\", string.Format(@\"// Reference: https://www.sqlbi.com/articles/rolling-12-months-average-in-dax/\r\nVAR _LastDayShown = {0}\r\nVAR _NumOfMonths = 12\r\nVAR _ReferenceDate = \r\n    CALCULATE(\r\n        MAX({1}),\r\n        FILTER(VALUES({1}), \r\n        {1} <= _LastDayShown\r\n        )\r\n    )\r\n    \r\nVAR _PreviousDates =\r\n    DATESINPERIOD({1}, _ReferenceDate, -_NumOfMonths, MONTH)\r\n\r\nVAR _CurrentResult =\r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        _PreviousDates\r\n    )\r\nVAR _PreviousResult =\r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        SAMEPERIODLASTYEAR(_PreviousDates)\r\n    )\r\n    \r\nVAR _DeviationResult = _CurrentResult - _PreviousResult\r\nVAR _firstDateInPeriod = MINX(_PreviousDates, {1})\r\n\r\nRETURN \r\n    IF(_firstDateInPeriod <= _ReferenceDate, DIVIDE(_DeviationResult, _PreviousResult))\", _LastDateAvailable, _CalendarDate), ordinal++, \"Rolling 12 months Index %\", \"\\\"0%\\\"\");\r\n        continue;\r\n    }\r\n    \r\n    \r\n    \r\n    if (item == \"Rolling average\")\r\n    {\r\n        if (!string.IsNullOrEmpty(_selectedAverage))\r\n        {\r\n            AddCalculationItemIfNotExists(\"Rolling 12M avg\", string.Format(@\"// Reference: https://www.sqlbi.com/articles/rolling-12-months-average-in-dax/\r\n\r\n //Calculating the average based on the selection in VALUES, such as per day or per month\r\n \r\nVAR _LastDayShown = {0}\r\n        \r\nVAR _NumOfMonths = 12\r\n// Hiding future days. If not remove the calculate in _ReferenceDate\r\nVAR  _LastCurrentDate = CALCULATE(\r\n    max({1}), FILTER(\r\n        VALUES( {1} ),\r\n        {1} <= _LastDayShown\r\n    )\r\n)\r\n\r\n VAR _Period =\r\n        DATESINPERIOD ( {1}, _LastCurrentDate, - _NumOfMonths, MONTH )  \r\n    \r\nVAR _Result =\r\n        CALCULATE (\r\n            AVERAGEX (\r\n                VALUES ( {2} ),     \r\n                SELECTEDMEASURE () \r\n            ),\r\n            _Period\r\n        ) \r\n    \r\n     VAR _firstDateInPeriod = MINX ( _Period, {1} )\r\n   \r\n    \r\nRETURN \r\n    IF ( _firstDateInPeriod <= _LastCurrentDate, _Result )\",\r\n    _LastDateAvailable, _CalendarDate, _selectedAverage),\r\n    ordinal++,\r\n    string.Format(\"Rolling 12 months average per {0}, hiding future dates\", _selectedAverage),\r\n    null);\r\n        }\r\n        continue;\r\n    }\r\n    \r\n        if (item == \"Rolling total\")\r\n        {     \r\n    AddCalculationItemIfNotExists(\"Rolling Total\", string.Format(@\"\r\nvar _currdate= {0}\r\n\r\nRETURN\r\n    CALCULATE(\r\n        SELECTEDMEASURE(),\r\n        FILTER(\r\n            ALLSELECTED({1}),\r\n            ISONORAFTER({1}, _currdate, DESC)\r\n        )\r\n    )\r\n\r\n     \"\r\n        , _LastDateAvailable, _CalendarDate), ordinal++,\r\n        \"Running Total, from the first date available until selected date\", null);\r\n        continue;\r\n    }\r\n    \r\n   \r\n    // Placeholder: additional Time Intelligence logic goes here\r\n  //  AddCalculationItemIfNotExists(item, \"SELECTEDMEASURE()\", ordinal++, \"Time Intelligence - \" + item, null);\r\n}\r\n\r\nif (skippedItems.Count > 0)\r\n{\r\nstring message = \"The following calculation item(s) were skipped because they already exist:\\n\\n\" + string.Join(\"\\n\", skippedItems);\r\n\r\n    MessageBox.Show(message, \"Items Skipped\", MessageBoxButtons.OK, MessageBoxIcon.Information);\r\n}\r\n\r\n\r\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "3. Calculation Groups and FP\\3. Units Calculation group",
      "Enabled": "true",
      "Execute": "\r\n// The purpose of this macro is easily being able to modify units displayed\r\n// It will then discourage if measure contains % or idx in the name\r\n\r\n//\r\n // Title: Units calculation group\r\n // \r\n // Source: Alexander Korn\r\n // \r\n // This script is inpired by part of this script https://github.com/KornAlexander/PBI-Tools/blob/main/Power%20BI-Pimp-Script.csx.\r\n // Some minor adjustments are included:\r\n //         Adding actual\r\n //         Tailored to be run from a New Calculation Group in Tabular Editor 2\r\n\r\n\r\n\r\nusing System;\r\nusing System.Linq;\r\nusing System.Windows.Forms;\r\nusing TabularEditor.TOMWrapper;\r\n\r\npublic class InputDialog\r\n{\r\n    public static string ShowInputDialog(string text, string caption, string defaultValue)\r\n    {\r\n        Form prompt = new Form()\r\n        {\r\n            Width = 600,\r\n            Height = 150,\r\n            FormBorderStyle = FormBorderStyle.FixedDialog,\r\n            Text = caption,\r\n            StartPosition = FormStartPosition.CenterScreen\r\n        };\r\n        Label textLabel = new Label() { Left = 50, Top = 20, Text = text, AutoSize = true };\r\n        TextBox textBox = new TextBox() { Left = 50, Top = 50, Width = 500, Text = defaultValue };\r\n        Button confirmation = new Button() { Text = \"OK\", Left = 450, Width = 100, Top = 70, DialogResult = DialogResult.OK };\r\n        confirmation.Click += (sender, e) => { prompt.Close(); };\r\n        prompt.Controls.Add(textLabel);\r\n        prompt.Controls.Add(textBox);\r\n        prompt.Controls.Add(confirmation);\r\n        prompt.AcceptButton = confirmation;\r\n\r\n        return prompt.ShowDialog() == DialogResult.OK ? textBox.Text.Trim() : \"\";\r\n    }\r\n}\r\n\r\n// Disable spinner and wait cursor\r\nScriptHelper.WaitFormVisible = false;\r\nApplication.UseWaitCursor = false;\r\n\r\n// Get the selected Calculation Group Table\r\nvar cgTable = Selected.Tables.FirstOrDefault() as CalculationGroupTable;\r\n\r\nif (cgTable != null && cgTable.Name.StartsWith(\"New Calculation Group\"))\r\n{\r\n    string defaultTableName = \"Unit\";\r\n    string newTableName = InputDialog.ShowInputDialog(\"Enter new name for the calculation group table:\", \"Rename Calculation Group Table\", defaultTableName);\r\n\r\n    if (!string.IsNullOrEmpty(newTableName))\r\n    {\r\n        cgTable.Name = newTableName;\r\n        cgTable.Columns[\"Name\"].Name = \"Unit\";\r\n        cgTable.CalculationGroup.Precedence = 2;\r\n    }\r\n}\r\nelse\r\n{\r\n    Output(\"Table name does not start with 'New Calculation Group'. Keeping existing name and precedence.\");\r\n}\r\n\r\n// Add \"Actual\" calculation item\r\nvar actual = cgTable.AddCalculationItem(\"Actual\");\r\nactual.Expression = \"SELECTEDMEASURE()\";\r\nactual.Description = \"Actual value\";\r\nactual.Ordinal = 0;\r\nactual.Expression = FormatDax(actual.Expression);\r\n\r\n// Add \"Thousand\" calculation item\r\nvar thousand = cgTable.AddCalculationItem(\"Thousand\");\r\nthousand.Expression = @\"\r\nIF(ISNUMBER(SELECTEDMEASURE()),\r\n    IF(\r\n        NOT(CONTAINSSTRING(SELECTEDMEASURENAME(), \"\"%\"\") || CONTAINSSTRING(SELECTEDMEASURENAME(), \"\"idx\"\")),\r\n        DIVIDE(SELECTEDMEASURE(), 1000),\r\n        SELECTEDMEASURE()\r\n    ),\r\n    SELECTEDMEASURE()\r\n)\";\r\nthousand.Description = \"Value divided by Thousand\";\r\nthousand.Ordinal = 1;\r\nthousand.Expression = FormatDax(thousand.Expression);\r\n\r\n// Add \"Million\" calculation item\r\nvar million = cgTable.AddCalculationItem(\"Million\");\r\nmillion.Expression = @\"\r\nIF(ISNUMBER(SELECTEDMEASURE()),\r\n    IF(\r\n        NOT(CONTAINSSTRING(SELECTEDMEASURENAME(), \"\"%\"\") || CONTAINSSTRING(SELECTEDMEASURENAME(), \"\"idx\"\")),\r\n        DIVIDE(SELECTEDMEASURE(), 1000000),\r\n        SELECTEDMEASURE()\r\n    ),\r\n    SELECTEDMEASURE()\r\n)\";\r\nmillion.Description = \"Value divided by Million\";\r\nmillion.Ordinal = 2;\r\nmillion.Expression = FormatDax(million.Expression);\r\n",
      "Tooltip": "For a selected calculation group, creates the Unit conversion",
      "ValidContexts": "CalculationGroupTable"
    },
    {
      "Name": "4. Create Measures\\4. Auto-generate SUM measures for selected columns",
      "Enabled": "true",
      "Execute": "// This is a modification of the auto-generate script provided by Tabular Editor.\r\n// It is modified such that the user can select the table where the new measure is to be added\r\n// It adds logic setting AvailableInMDX = False for the base column\r\n\r\n//\r\n // Title: Auto-generate SUM measures from columns\r\n // \r\n // Author: Daniel Otykier, twitter.com/DOtykier\r\n // \r\n // This script, when executed, will loop through the currently selected columns,\r\n // creating one SUM measure for each column and also hiding the column itself.\r\n //\r\n\r\n\r\nusing System.Windows.Forms;\r\nusing System.Linq;\r\n\r\n// Prompt: Add to custom table?\r\nvar result = MessageBox.Show(\r\n    \"Do you want to add the new measure(s) to a custom table?\\n\\nClick 'Yes' to choose a table.\\nClick 'No' to add to each column's original table.\",\r\n    \"Choose Target Table\",\r\n    MessageBoxButtons.YesNoCancel\r\n);\r\n\r\nif (result == DialogResult.Cancel)\r\n{\r\n    return; // User cancelled\r\n}\r\n\r\nTable selectedTable = null;\r\n\r\nif (result == DialogResult.Yes)\r\n{\r\n    // Build a form with a ListBox for table selection\r\n    Form form = new Form();\r\n    ListBox listBox = new ListBox();\r\n    Button okButton = new Button();\r\n    Button cancelButton = new Button();\r\n\r\n    form.Text = \"Select a Table\";\r\n    form.Width = 400;\r\n    form.Height = 300;\r\n    form.FormBorderStyle = FormBorderStyle.FixedDialog;\r\n    form.StartPosition = FormStartPosition.CenterScreen;\r\n    form.MinimizeBox = false;\r\n    form.MaximizeBox = false;\r\n\r\n    listBox.Width = 360;\r\n    listBox.Height = 200;\r\n    listBox.Left = 10;\r\n    listBox.Top = 10;\r\n    listBox.SelectionMode = SelectionMode.One;\r\n    listBox.DataSource = Model.Tables.Select(t => t.Name).ToList();\r\n\r\n    okButton.Text = \"OK\";\r\n    okButton.Left = 220;\r\n    okButton.Top = 220;\r\n    okButton.DialogResult = DialogResult.OK;\r\n\r\n    cancelButton.Text = \"Cancel\";\r\n    cancelButton.Left = 300;\r\n    cancelButton.Top = 220;\r\n    cancelButton.DialogResult = DialogResult.Cancel;\r\n\r\n    form.Controls.Add(listBox);\r\n    form.Controls.Add(okButton);\r\n    form.Controls.Add(cancelButton);\r\n\r\n    form.AcceptButton = okButton;\r\n    form.CancelButton = cancelButton;\r\n\r\n    var dialogResult = form.ShowDialog();\r\n\r\n    if (dialogResult == DialogResult.OK && listBox.SelectedItem != null)\r\n    {\r\n        string tableName = listBox.SelectedItem.ToString();\r\n        if (!string.IsNullOrEmpty(tableName) && Model.Tables.Contains(tableName))\r\n        {\r\n            selectedTable = Model.Tables[tableName];\r\n        }\r\n    }\r\n    else\r\n    {\r\n        Info(\"No table selected. Measures will be added to the column's original table.\");\r\n    }\r\n}\r\n\r\n// Loop through selected columns and add SUM measures\r\nforeach (var c in Selected.Columns)\r\n{\r\n    var finalTable = selectedTable ?? c.Table;\r\n    var daxExpression = \"SUM(\" + c.DaxObjectFullName + \")\";\r\n\r\n    bool measureExists = Model.AllMeasures.Any(m =>\r\n        m.Expression.Replace(\" \", \"\").Replace(\"\\n\", \"\").Replace(\"\\r\", \"\").Replace(\"\\t\", \"\") == daxExpression.Replace(\" \", \"\")\r\n    );\r\n\r\n    if (!measureExists)\r\n    {\r\n        var measure = finalTable.AddMeasure(\r\n            \"Total \" + c.Name,\r\n            daxExpression,\r\n            c.Table.Name\r\n        );\r\n\r\n        measure.FormatString = \"#,0\";\r\n        measure.Description = \"This measure is the sum of column \" + c.DaxObjectFullName;\r\n\r\n        c.IsHidden = true;\r\n        c.IsAvailableInMDX = false;\r\n\r\n        c.SummarizeBy = AggregateFunction.None;\r\n    }\r\n    else\r\n    {\r\n        Output(\"Skipped: Measure already exists for column '\" + c.Name + \"' with expression '\" + daxExpression + \"'\");\r\n    }\r\n}\r\n\r\n",
      "Tooltip": "Creates sum for selected column, and perform operations on the base column, like hiding, do not summarize and not available in MDX. Sets description and format no measure.",
      "ValidContexts": "Column"
    },
    {
      "Name": "4. Create Measures\\4. Count rows for selected column(s)",
      "Enabled": "true",
      "Execute": "// This is a modification of the script provided by Tabular Editor.\r\n// It is modified such that the user can select the table where the new measure is to be added\r\n// It also added logic to check whether the measure previously have been created\r\n\r\n// Author: Daniel Otykier, twitter.com/DOtykier\r\n // \r\n // This script, when executed, will loop through the currently selected columns,\r\n // creating one Count measure for each column.\r\n //\r\n \r\n\r\n\r\nusing System.Windows.Forms;\r\nusing System.Linq;\r\n\r\n// Prompt: Add to custom table?\r\nvar result = MessageBox.Show(\r\n    \"Do you want to add the new measure(s) to a custom table?\\n\\nClick 'Yes' to choose a table.\\nClick 'No' to add to each column's original table.\",\r\n    \"Choose Target Table\",\r\n    MessageBoxButtons.YesNoCancel\r\n);\r\n\r\nif (result == DialogResult.Cancel)\r\n{\r\n    return; // User cancelled\r\n}\r\n\r\nTable selectedTable = null;\r\n\r\nif (result == DialogResult.Yes)\r\n{\r\n    // Build a form with a ListBox for table selection\r\n    var form = new Form();\r\n    var listBox = new ListBox();\r\n    var okButton = new Button();\r\n    var cancelButton = new Button();\r\n\r\n    form.Text = \"Select a Table\";\r\n    form.Width = 400;\r\n    form.Height = 300;\r\n    form.FormBorderStyle = FormBorderStyle.FixedDialog;\r\n    form.StartPosition = FormStartPosition.CenterScreen;\r\n    form.MinimizeBox = false;\r\n    form.MaximizeBox = false;\r\n\r\n    listBox.Width = 360;\r\n    listBox.Height = 200;\r\n    listBox.Left = 10;\r\n    listBox.Top = 10;\r\n    listBox.SelectionMode = SelectionMode.One;\r\n    listBox.DataSource = Model.Tables.Select(t => t.Name).ToList();\r\n\r\n    okButton.Text = \"OK\";\r\n    okButton.Left = 220;\r\n    okButton.Top = 220;\r\n    okButton.DialogResult = DialogResult.OK;\r\n\r\n    cancelButton.Text = \"Cancel\";\r\n    cancelButton.Left = 300;\r\n    cancelButton.Top = 220;\r\n    cancelButton.DialogResult = DialogResult.Cancel;\r\n\r\n    form.Controls.Add(listBox);\r\n    form.Controls.Add(okButton);\r\n    form.Controls.Add(cancelButton);\r\n\r\n    form.AcceptButton = okButton;\r\n    form.CancelButton = cancelButton;\r\n\r\n    var dialogResult = form.ShowDialog();\r\n\r\n    if (dialogResult == DialogResult.OK && listBox.SelectedItem != null)\r\n    {\r\n        string tableName = listBox.SelectedItem.ToString();\r\n        if (!string.IsNullOrEmpty(tableName) && Model.Tables.Contains(tableName))\r\n        {\r\n            selectedTable = Model.Tables[tableName];\r\n        }\r\n    }\r\n    else\r\n    {\r\n        Info(\"No table selected. Measures will be added to the column's original table.\");\r\n    }\r\n}\r\n\r\n// Loop through selected columns and add SUM measures\r\nforeach (var c in Selected.Columns)\r\n{\r\n    var finalTable = selectedTable ?? c.Table;\r\n  \r\n\r\n        // Check if the measure already exists\r\n        bool measureExists = Model.AllMeasures\r\n            .Any(existingMeasure => \r\n                existingMeasure.Expression.Replace(\" \", \"\").Replace(\"\\n\", \"\").Replace(\"\\r\", \"\").Replace(\"\\t\", \"\") == (\"COUNTROWS(VALUES(\" + c.DaxObjectFullName + \"))\")\r\n            \r\n            );\r\n\r\n    if (!measureExists)\r\n    {\r\n // Add the new measure if it doesn't exist\r\n            var newMeasure = finalTable.AddMeasure(\r\n                \"# \" + c.Name,                    // Name\r\n                \"COUNTROWS(VALUES(\" + c.DaxObjectFullName + \"))\",    // DAX expression\r\n                c.Table.Name               // Display Folder\r\n            );\r\n\r\n            // Set the format string and description for the new measure\r\n            newMeasure.FormatString = \"#,0\";\r\n            newMeasure.Description = \"This measure counts the distinct rows of \" + c.DaxObjectFullName;\r\n            newMeasure.Expression = FormatDax(newMeasure.Expression, shortFormat: true, skipSpaceAfterFunctionName: true);\r\n    }\r\n}\r\n",
      "Tooltip": "Counts the rows for selected columns",
      "ValidContexts": "Column"
    },
    {
      "Name": "4. Create Measures\\4. Count rows in selected table(s)",
      "Enabled": "true",
      "Execute": "\r\n// This is a modification of the script to display number of rows in a table provided by Tabular Editor.\r\n// It is modified such that the user can select the table where the new measure is to be added\r\n// It does not check whether the measure already exists\r\n\r\n // Title: Count rows in selected table(s)\r\n // \r\n // \r\n // This script, when executed, will loop through the currently selected tables,\r\n // creating one countrows measure for each table.\r\n \r\n\r\n\r\nusing System.Windows.Forms;\r\nusing System.Linq;\r\n\r\n// Prompt: Add to custom table?\r\nvar result = MessageBox.Show(\r\n    \"Do you want to add the new measure(s) to a custom table?\\n\\nClick 'Yes' to choose a table.\\nClick 'No' to add to each table individually.\",\r\n    \"Choose Target Table\",\r\n    MessageBoxButtons.YesNoCancel\r\n);\r\n\r\nif (result == DialogResult.Cancel)\r\n{\r\n    return; // User cancelled\r\n}\r\n\r\nTable selectedTable = null;\r\n\r\nif (result == DialogResult.Yes)\r\n{\r\n    // Build a form with a ListBox for table selection\r\n    var form = new Form();\r\n    var listBox = new ListBox();\r\n    var okButton = new Button();\r\n    var cancelButton = new Button();\r\n\r\n    form.Text = \"Select a Table\";\r\n    form.Width = 400;\r\n    form.Height = 300;\r\n    form.FormBorderStyle = FormBorderStyle.FixedDialog;\r\n    form.StartPosition = FormStartPosition.CenterScreen;\r\n    form.MinimizeBox = false;\r\n    form.MaximizeBox = false;\r\n\r\n    listBox.Width = 360;\r\n    listBox.Height = 200;\r\n    listBox.Left = 10;\r\n    listBox.Top = 10;\r\n    listBox.SelectionMode = SelectionMode.One;\r\n    listBox.DataSource = Model.Tables.Select(t => t.Name).ToList();\r\n\r\n    okButton.Text = \"OK\";\r\n    okButton.Left = 220;\r\n    okButton.Top = 220;\r\n    okButton.DialogResult = DialogResult.OK;\r\n\r\n    cancelButton.Text = \"Cancel\";\r\n    cancelButton.Left = 300;\r\n    cancelButton.Top = 220;\r\n    cancelButton.DialogResult = DialogResult.Cancel;\r\n\r\n    form.Controls.Add(listBox);\r\n    form.Controls.Add(okButton);\r\n    form.Controls.Add(cancelButton);\r\n\r\n    form.AcceptButton = okButton;\r\n    form.CancelButton = cancelButton;\r\n\r\n    var dialogResult = form.ShowDialog();\r\n\r\n    if (dialogResult == DialogResult.OK && listBox.SelectedItem != null)\r\n    {\r\n        string tableName = listBox.SelectedItem.ToString();\r\n        if (!string.IsNullOrEmpty(tableName) && Model.Tables.Contains(tableName))\r\n        {\r\n            selectedTable = Model.Tables[tableName];\r\n        }\r\n    }\r\n    else\r\n    {\r\n        Info(\"No table selected. Measures will be added to each original table.\");\r\n    }\r\n}\r\n\r\n// Loop through selected tables and add \"# Rows\" measures\r\nforeach (var t in Selected.Tables)\r\n{\r\n    var finalTable = selectedTable ?? t;\r\n\r\n    string measureName = string.Format(\"# Rows {0}\", t.Name);\r\n    string expression = string.Format(\"COUNTROWS({0})\", t.DaxObjectFullName);\r\n\r\n    // Check if a measure with the same name already exists in the final table\r\n    bool measureExists = finalTable.Measures\r\n        .Any(m => m.Name.Equals(measureName, System.StringComparison.OrdinalIgnoreCase));\r\n\r\n    if (!measureExists)\r\n    {\r\n        var newMeasure = finalTable.AddMeasure(\r\n            measureName,\r\n            expression,\r\n            t.Name // Display Folder\r\n        );\r\n\r\n        newMeasure.FormatString = \"#,0\";\r\n        newMeasure.Description = string.Format(\"This measure counts the number of rows in the table {0}\", t.DaxObjectFullName);\r\n\r\n        // Optional formatting\r\n        newMeasure.Expression = FormatDax(newMeasure.Expression, shortFormat: true, skipSpaceAfterFunctionName: true);\r\n    }\r\n}\r\n",
      "Tooltip": "Counts the number of rows for selected tables",
      "ValidContexts": "Table"
    },
    {
      "Name": "4. Create Measures\\4. Create measure Deviation (e.g. Profit or target)",
      "Enabled": "true",
      "Execute": "\r\n//\r\n // Title: Create measure Deviation (e.g. Profit/ to target)\r\n // \r\n // Author: Eivind Haugen\r\n // \r\n // This script, when executed, will let you create a measure with deviation and % difference between measures (only selection two measures is an option\r\n // \r\n // The purpose of the script is to ensure best practice is included when creating measures. \r\n //\r\n // Typical use case is to calculat Profit and Margin %, or difference to a target\r\n //\r\n\r\n\r\nusing System;\r\nusing System.Linq;\r\nusing System.Windows.Forms;\r\n\r\npublic class InputDialog\r\n{\r\n    public static string ShowInputDialog(string text, string caption, string defaultValue)\r\n    {\r\n        Form prompt = new Form()\r\n        {\r\n            Width = 600,\r\n            Height = 150,\r\n            FormBorderStyle = FormBorderStyle.FixedDialog,\r\n            Text = caption,\r\n            StartPosition = FormStartPosition.CenterScreen\r\n        };\r\n        Label textLabel = new Label() { Left = 50, Top = 20, Text = text, AutoSize = true };\r\n        TextBox textBox = new TextBox() { Left = 50, Top = 50, Width = 500, Text = defaultValue };\r\n        Button confirmation = new Button() { Text = \"OK\", Left = 450, Width = 100, Top = 70, DialogResult = DialogResult.OK };\r\n        confirmation.Click += (sender, e) => { prompt.Close(); };\r\n        prompt.Controls.Add(textLabel);\r\n        prompt.Controls.Add(textBox);\r\n        prompt.Controls.Add(confirmation);\r\n        prompt.AcceptButton = confirmation;\r\n\r\n        return prompt.ShowDialog() == DialogResult.OK ? textBox.Text.Trim() : \"\";\r\n    }\r\n}\r\n\r\n// Hide spinner and cursor\r\nScriptHelper.WaitFormVisible = false;\r\nApplication.UseWaitCursor = false;\r\n\r\n// Input dialogs\r\nstring deviationName = InputDialog.ShowInputDialog(\"Provide the name for deviation measure\", \"Measure Name\", \"Profit\");\r\nstring deviationPctName = InputDialog.ShowInputDialog(\"Provide the name for deviation % measure\", \"Measure Name % change\", \"Margin %\");\r\n\r\n// Check if exactly two measures are selected\r\nif (Selected.Measures.Count != 2)\r\n{\r\n    Error(\"You must select exactly two measures!\");\r\n    return;\r\n}\r\n\r\n// Retrieve the selected measures\r\nvar selectedMeasures = Selected.Measures.ToList();\r\nvar measure1 = selectedMeasures[0];\r\nvar measure2 = selectedMeasures[1];\r\n\r\n// Clean variable names\r\nstring var1 = \"_\" + measure1.Name.Replace(\" \", \"_\");\r\nstring var2 = \"_\" + measure2.Name.Replace(\" \", \"_\");\r\nstring varDev = \"_deviation\";\r\n\r\n// Create DAX expressions\r\nstring daxDeviation = measure1.DaxObjectName + \" - \" + measure2.DaxObjectName;\r\n\r\nstring daxDeviationPct =\r\n    \"VAR \" + var1 + \" = \" + measure1.DaxObjectName + \"\\n\" +\r\n    \"VAR \" + var2 + \" = \" + measure2.DaxObjectName + \"\\n\" +\r\n    \"VAR \" + varDev + \" = \" + var1 + \" - \" + var2 + \"\\n\" +\r\n    \"RETURN DIVIDE(\" + varDev + \", \" + var2 + \")\";\r\n\r\nvar targetTable = measure1.Table;\r\n\r\n// Create deviation measure\r\nif (!string.IsNullOrWhiteSpace(deviationName))\r\n{\r\n    var m = targetTable.AddMeasure(deviationName, daxDeviation, measure1.DisplayFolder);\r\n    m.FormatString = measure1.FormatString;\r\n    m.Description = \"This measure is the deviation between \" + measure1.DaxObjectFullName + \" and \" + measure2.DaxObjectFullName;\r\n    m.Expression = FormatDax(m.Expression, shortFormat: true, skipSpaceAfterFunctionName: true);\r\n}\r\n\r\n// Create deviation % measure\r\nif (!string.IsNullOrWhiteSpace(deviationPctName))\r\n{\r\n    var mPct = targetTable.AddMeasure(deviationPctName, daxDeviationPct, measure1.DisplayFolder);\r\n    mPct.FormatString = \"#,0.0%;-#,0.0%;#,0.0%\";\r\n    mPct.Description = \"This measure is the % change between \" + measure1.DaxObjectFullName + \" and \" + measure2.DaxObjectFullName;\r\n    mPct.Expression = FormatDax(mPct.Expression, shortFormat: true, skipSpaceAfterFunctionName: true);\r\n}\r\n",
      "Tooltip": "For 2 selected measures, it finds the deviation in number and % based on the 1st and 2nd selection. User can specify names",
      "ValidContexts": "Measure"
    },
    {
      "Name": "8. Model documentation\\8. Create model documentation",
      "Enabled": "true",
      "Execute": "// Credit to Fernan for original DAX idea\r\n// Converted to C# Script from DAX script created by David Kofod Hanna\r\n\r\n// Check if the calculated table already exists, if so delete it\r\nvar existingTable = Model.Tables.FirstOrDefault(t => t.Name == \"Model Documentation\");\r\nif (existingTable != null)\r\n{\r\n    existingTable.Delete();\r\n}\r\n\r\n// DAX to create the calculated table\r\nvar docTableDax = @\"\r\nVAR _columns =\r\n    SELECTCOLUMNS(\r\n        FILTER(\r\n            INFO.VIEW.COLUMNS(),\r\n            [Table] <> \"\"Model Documentation\"\" && NOT([IsHidden])\r\n        ),\r\n        \"\"Type\"\", \"\"Column\"\",\r\n        \"\"Name\"\", [Name],\r\n        \"\"Description\"\", [Description],\r\n        \"\"Location\"\", [Table],\r\n        \"\"Expression\"\", [Expression]\r\n    )\r\nVAR _measures =\r\n    SELECTCOLUMNS(\r\n        FILTER(\r\n            INFO.VIEW.MEASURES(),\r\n            [Table] <> \"\"Model Documentation\"\" && NOT([IsHidden])\r\n        ),\r\n        \"\"Type\"\", \"\"Measure\"\",\r\n        \"\"Name\"\", [Name],\r\n        \"\"Description\"\", [Description],\r\n        \"\"Location\"\", [Table],\r\n        \"\"Expression\"\", [Expression]\r\n    )\r\nVAR _tables =\r\n    SELECTCOLUMNS(\r\n        FILTER(\r\n            INFO.VIEW.TABLES(),\r\n            [Name] <> \"\"Model Documentation\"\" && [Name] <> \"\"Calculations\"\" && NOT([IsHidden])\r\n        ),\r\n        \"\"Type\"\", \"\"Table\"\",\r\n        \"\"Name\"\", [Name],\r\n        \"\"Description\"\", [Description],\r\n        \"\"Location\"\", BLANK(),\r\n        \"\"Expression\"\", [Expression]\r\n    )\r\nVAR _relationships =\r\n    SELECTCOLUMNS(\r\n        INFO.VIEW.RELATIONSHIPS(),\r\n        \"\"Type\"\", \"\"Relationship\"\",\r\n        \"\"Name\"\", [Relationship],\r\n        \"\"Description\"\", BLANK(),\r\n        \"\"Location\"\", BLANK(),\r\n        \"\"Expression\"\", [Relationship]\r\n    )\r\nRETURN\r\n    UNION(_columns, _measures, _tables, _relationships)\r\n\";\r\n\r\n// Create the new calculated table\r\nvar documentationTable = Model.AddCalculatedTable(\"Model Documentation\", docTableDax);\r\n\r\n// Create the measures\r\nvar measure1 = documentationTable.AddMeasure(\r\n    \"# of Measures\",\r\n    \"CALCULATE(COUNTROWS('Model Documentation'), 'Model Documentation'[Type] = \\\"Measure\\\")\"\r\n);\r\nmeasure1.FormatString = \"#,0\";\r\nmeasure1.Description = \"COUNTROWS('Model Documentation') where Type = 'Measure'\";\r\n\r\nvar measure2 = documentationTable.AddMeasure(\r\n    \"# of Columns\",\r\n    \"CALCULATE(COUNTROWS('Model Documentation'), 'Model Documentation'[Type] = \\\"Column\\\")\"\r\n);\r\nmeasure2.FormatString = \"#,0\";\r\nmeasure2.Description = \"COUNTROWS('Model Documentation') where Type = 'Column'\";\r\n\r\nvar measure3 = documentationTable.AddMeasure(\r\n    \"# of Tables\",\r\n    \"CALCULATE(COUNTROWS('Model Documentation'), 'Model Documentation'[Type] = \\\"Table\\\")\"\r\n);\r\nmeasure3.FormatString = \"#,0\";\r\nmeasure3.Description = \"COUNTROWS('Model Documentation') where Type = 'Table'\";\r\n\r\nvar measure4 = documentationTable.AddMeasure(\r\n    \"# of Relationship\",\r\n    \"CALCULATE(COUNTROWS('Model Documentation'), 'Model Documentation'[Type] = \\\"Relationship\\\")\"\r\n);\r\nmeasure4.FormatString = \"#,0\";\r\nmeasure4.Description = \"COUNTROWS('Model Documentation') where Type = 'Relationship'\";\r\n\r\n// Optional: Refresh schema (Tabular Editor 3 only)\r\n// Model.Sync();\r\n",
      "Tooltip": "Creates model documentation, using info-view",
      "ValidContexts": "Model"
    },
    {
      "Name": "9. Best Practice Rules\\9.1 Do not summarize ID, Key and numeric columns",
      "Enabled": "true",
      "Execute": "// Inspired by Alexander Korn's PIMP script: https://github.com/KornAlexander/PBI-Tools/blob/main/PIMP-Script.ps1\r\n\r\n// Added logic to include all numeric columns, to align with Microsoft Best Practice rules\r\n\r\n\r\nforeach (var table in Model.Tables)\r\n{\r\n    foreach (var column in table.Columns)\r\n    {\r\n        // Set SummarizeBy to None for columns ending in \"Key\" or \"ID\"\r\n        if (column.Name.EndsWith(\"Key\") || column.Name.EndsWith(\"ID\"))\r\n        {\r\n            column.SummarizeBy = AggregateFunction.None;\r\n        }\r\n\r\n        // Set SummarizeBy to None for numeric columns not already set to None, not hidden, and not from hidden tables\r\n        if ((column.DataType == DataType.Int64 ||\r\n             column.DataType == DataType.Decimal ||\r\n             column.DataType == DataType.Double) &&\r\n            column.SummarizeBy != AggregateFunction.None &&\r\n            !column.IsHidden &&\r\n            !column.Table.IsHidden)\r\n        {\r\n            column.SummarizeBy = AggregateFunction.None;\r\n        }\r\n    }\r\n}\r\n",
      "Tooltip": "Makes sure that all numeric columns or technical columns are not summarized",
      "ValidContexts": "Model"
    },
    {
      "Name": "9. Best Practice Rules\\9.2 Provide format string for Date-columns",
      "Enabled": "true",
      "Execute": "\r\n// Created by Eivind Haugen\r\n// To ensure consistency in date-format\r\n\r\n// NB! Using the fromat mm/dd/yyyy similar to Best Practice rules from Microsoft and should be aligned if other fo\r\n\r\n\r\nforeach (var table in Model.Tables)\r\n{\r\n    foreach (var column in table.Columns)\r\n    {\r\n        // Check if the column name contains \"Date\" (case insensitive)\r\n        bool containsDate = column.Name.IndexOf(\"Date\", StringComparison.OrdinalIgnoreCase) >= 0;\r\n\r\n        // Check if the column is of DateTime data type\r\n        bool isDateTime = column.DataType == TabularEditor.TOMWrapper.DataType.DateTime;\r\n\r\n        // Check if the column format is NOT \"mm/dd/yyyy\"\r\n        bool incorrectFormat = column.FormatString != \"mm/dd/yyyy\";\r\n\r\n        // Apply the format change if all conditions are met\r\n        if (containsDate && isDateTime && incorrectFormat)\r\n        {\r\n            column.FormatString = \"mm/dd/yyyy\";\r\n        }\r\n    }\r\n}\r\n",
      "Tooltip": "Sets a format string to mm/dd/yyyy",
      "ValidContexts": "Model"
    },
    {
      "Name": "9. Best Practice Rules\\9.3 Hide columns on the many side of a relationship",
      "Enabled": "true",
      "Execute": "\r\n//\r\n // Title: Hide columns on the many side of a relationship  \r\n //\r\n // Author: Matt Allington, https://exceleratorbi.com.au  \r\n //\r\n // it is dangerous to use columns on the many side of a relationship as it can \r\n // produce unexpected results, so it is a best practice to hide these columns\r\n // to discourage their use in reports.\r\n //\r\n\r\n // It is modified to not hide the relationship if the many-side is of datetype=DateTime\r\n \r\n\r\nusing System.Windows.Forms;\r\n\r\nstring skipped = \"\";\r\n\r\nforeach (var r in Model.Relationships)\r\n{\r\n    var fromColumn = r.FromColumn;\r\n    var fromTable = r.FromTable;\r\n\r\n    // Safe access: no casting needed\r\n    if (fromColumn.DataType != DataType.DateTime)\r\n    {\r\n        fromColumn.IsHidden = true;\r\n    }\r\n    else\r\n    {\r\n        skipped += \"Skipped hiding: \" + fromTable.Name + \"[\" + fromColumn.Name + \"] as date-columns may be used for reporting. Hide manually if applicable\\n\";\r\n    }\r\n}\r\n\r\n// Show message box if there are skipped columns\r\nif (!string.IsNullOrEmpty(skipped))\r\n{\r\n    MessageBox.Show(skipped, \"Skipped Columns\");\r\n}\r\n",
      "Tooltip": "Hides all columns on the many side of the relationship, unless it is a column with datetype = DateTime (as it may be needed for reporting)",
      "ValidContexts": "Model"
    },
    {
      "Name": "9. Best Practice Rules\\9.4 All columns ending with ID or Key, or non-attribute - Set IsAvailableInMDX to false",
      "Enabled": "true",
      "Execute": "\r\n// Se information on MDX functionality:  https://data-mozart.com/hidden-little-gem-that-can-save-your-power-bi-life/\r\n\r\n\r\n// Inspired by Alexander Korn's PIMP script: https://github.com/KornAlexander/PBI-Tools/blob/main/PIMP-Script.ps1\r\n\r\n// Added logic for all hidden columns that are not used as sort by/ in hierarchy/ variations, aligning with Best Practice rules from Microsoft\r\n\r\n\r\n// Ensure that IsAvailableInMDX is set to false if it is not to be used in Excel or as sorting for other columns etc\r\n\r\nforeach (var table in Model.Tables)\r\n{\r\n    foreach (var column in table.Columns)\r\n    {\r\n        // Set IsAvailableInMDX to false for columns ending in \"Key\" or \"ID\"\r\n        if (column.Name.EndsWith(\"Key\") || column.Name.EndsWith(\"ID\"))\r\n        {\r\n            column.IsAvailableInMDX = false;\r\n        }\r\n\r\n        // Set IsAvailableInMDX to false for hidden/unnecessary columns\r\n        if (column.IsAvailableInMDX &&\r\n            (column.IsHidden || column.Table.IsHidden) &&\r\n            !column.UsedInSortBy.Any() &&\r\n            !column.UsedInHierarchies.Any() &&\r\n            !column.UsedInVariations.Any() &&\r\n            column.SortByColumn == null)\r\n        {\r\n            column.IsAvailableInMDX = false;\r\n        }\r\n    }\r\n}\r\n",
      "Tooltip": "Will ensure not available in Analyze in Excel",
      "ValidContexts": "Model"
    },
    {
      "Name": "9. Best Practice Rules\\9.5 All columns - Set IsAvailableInMDX to false",
      "Enabled": "true",
      "Execute": "\r\n// Setting all columns to not available in MDX.\r\n// Se information:  https://data-mozart.com/hidden-little-gem-that-can-save-your-power-bi-life/\r\n\r\n// Ensure that IsAvailableInMDX is set to false if it is not to be used in Excel or as sorting for other columns etc\r\n\r\nforeach (var table in Model.Tables)\r\n{\r\n    foreach (var column in table.Columns)\r\n    {\r\n \r\n        column.IsAvailableInMDX = false;\r\n       \r\n    }\r\n}\r\n",
      "Tooltip": "Will ensure not available in Analyze in Excel for all columns",
      "ValidContexts": "Model"
    },
    {
      "Name": "9. Best Practice Rules\\9.6 Format selected measures",
      "Enabled": "true",
      "Execute": "if (Selected.Measures.Count == 0)\r\n{\r\n    Error(\"No measures selected. Please select one or more measures to format.\");\r\n    return;\r\n}\r\n\r\nif (Selected.Measures.Count > 20)\r\n{\r\n    Error(\"Too many measures selected. Reduce usage of DAXformatter\");\r\n    return;\r\n}\r\n\r\nforeach (var m in Selected.Measures)\r\n{\r\n    m.Expression = FormatDax(m.Expression, shortFormat: true, skipSpaceAfterFunctionName: true);\r\n    /* Format only the selected measures using DAX Formatter */\r\n}\r\n",
      "Tooltip": "Format selected measures, no more then 20 to reduce use of DAX formatter",
      "ValidContexts": "Measure"
    },
    {
      "Name": "9. Load best practice rules from Microsoft",
      "Enabled": "true",
      "Execute": "\r\n// Loading the best practice rules developed by Michael Kovalsky to the location where TE is installed\r\n\r\n// Download BPARules.json from GitHub to the correct folder based on TE version\r\nvar client = new System.Net.WebClient();\r\n\r\nstring localPath = System.Environment.GetFolderPath(System.Environment.SpecialFolder.LocalApplicationData);\r\nstring url = \"https://raw.githubusercontent.com/microsoft/Analysis-Services/master/BestPracticeRules/BPARules.json\";\r\n\r\n// Default to TE2 path\r\nstring destination = System.IO.Path.Combine(localPath, @\"TabularEditor\\BPARules.json\");\r\n\r\n// Adjust for TE3 if needed\r\nstring version = typeof(ScriptHelper).Assembly.GetName().Version.Major.ToString();\r\nif (version == \"3\")\r\n{\r\n    destination = System.IO.Path.Combine(localPath, @\"TabularEditor3\\BPARules.json\");\r\n}\r\n\r\n// Download file\r\nclient.DownloadFile(url, destination);\r\n\r\n// Confirm success\r\n//Info(\"Best Practice Analyzer rules downloaded to:\\n\" + destination);\r\n",
      "Tooltip": "Loads the best practice rules from Microsoft. Need to add file via downloaded file or URL",
      "ValidContexts": "Model"
    },
    {
      "Name": "4. Create Measures\\4. Create Time Intelligence measures",
      "Enabled": "true",
      "Execute": "//\r\n // Title: Create TI measures for selected measures with calc group Time Calculations\r\n // \r\n // Author: Eivind Haugen\r\n // \r\n // To execute this script, it will be executed based on a selected measure \r\n //     and next you are promted to selected the calculation item(s):\r\n\r\n // It runs a nested for-loop to create all the time intelligence measures\r\n // \r\n // For each measure with Time Intelligence, it will do the following:\r\n // 1. Creates the DAX expression from the selected Time Intelligence calculation item, and replaces selectedmeasure(), with the measure object (DaxObjectName)\r\n // 2. Adds a display-folder. \r\n // 3. Apply logic for formatting. If calculation contains idx, % or pct, always set to %, if not use the format from the selected measure\r\n // 4. Adds a description as a combination of the description for the measure and time intelligence\r\n // 5. Keeps the format of the Calculation item  expression, but not formatting via DAXformatter (if it's not formatted, it's not DAX)\r\n // \r\n // To ensure the best result, ensure that base-measures have format string and descriptions, and descriptions are included for time intelligence calculations\r\n //     - This is ensured if macros are run as part of this creation\r\n \r\n\r\n\r\n\r\n#r \"System.Drawing\"\r\nusing System.Windows.Forms;\r\nusing System.Drawing;\r\nusing System.Linq;\r\nusing System.Collections.Generic;\r\n\r\n// Hide script dialog and cursor\r\nScriptHelper.WaitFormVisible = false;\r\nApplication.UseWaitCursor = false;\r\n\r\n// STEP 1: Get list of calculation group tables and let user select one\r\nvar calcGroupTables = Model.Tables\r\n    .Where(t => t is CalculationGroupTable)\r\n    .Cast<CalculationGroupTable>()\r\n    .ToList();\r\n\r\nif (calcGroupTables.Count == 0)\r\n{\r\n    MessageBox.Show(\"No calculation groups found in the model.\");\r\n    return;\r\n}\r\n\r\nvar selectedCalcGroupTable = SelectTable(\r\n    calcGroupTables,\r\n    null,\r\n    \"Select a Calculation Group Table\"\r\n) as CalculationGroupTable;\r\n\r\nif (selectedCalcGroupTable == null)\r\n{\r\n    MessageBox.Show(\"No calculation group table selected.\");\r\n    return;\r\n}\r\n\r\n// STEP 2: Let user select multiple calculation items from that group\r\nvar calcItems = selectedCalcGroupTable.CalculationItems.ToList();\r\n\r\nForm calcItemForm = new Form();\r\nListBox calcItemListBox = new ListBox();\r\nButton calcItemOkButton = new Button();\r\nLabel calcItemLabel = new Label();\r\n\r\ncalcItemForm.Text = \"Select Calculation Items\";\r\ncalcItemForm.Width = 350;\r\ncalcItemForm.Height = 500;\r\n\r\ncalcItemListBox.Items.AddRange(calcItems.Select(ci => ci.Name).ToArray());\r\ncalcItemListBox.SelectionMode = SelectionMode.MultiExtended;\r\ncalcItemListBox.Location = new Point(50, 20);\r\ncalcItemListBox.Width = 200;\r\ncalcItemListBox.Height = 400;\r\n\r\ncalcItemOkButton.Text = \"OK\";\r\ncalcItemOkButton.Location = new Point(100, 430);\r\ncalcItemOkButton.Width = 100;\r\ncalcItemOkButton.Click += (sender, e) => { calcItemForm.Close(); };\r\n\r\ncalcItemLabel.Text = \"Select one or more calculation items:\";\r\ncalcItemLabel.Location = new Point(50, 0);\r\ncalcItemLabel.Width = 200;\r\n\r\ncalcItemForm.Controls.Add(calcItemListBox);\r\ncalcItemForm.Controls.Add(calcItemOkButton);\r\ncalcItemForm.Controls.Add(calcItemLabel);\r\n\r\ncalcItemForm.ShowDialog();\r\n\r\nvar selectedCalcItemNames = calcItemListBox.SelectedItems.Cast<string>().ToList();\r\nvar selectedCalcItems = calcItems.Where(ci => selectedCalcItemNames.Contains(ci.Name)).ToList();\r\n\r\nif (selectedCalcItems.Count == 0)\r\n{\r\n    MessageBox.Show(\"No calculation items selected.\");\r\n    return;\r\n}\r\n\r\n// STEP 3: Get already selected measures\r\nvar selectedMeasures = Selected.Measures.ToList();\r\n\r\nif (selectedMeasures.Count == 0)\r\n{\r\n    MessageBox.Show(\"No base measures selected in Tabular Editor.\");\r\n    return;\r\n}\r\n\r\n// STEP 4: Validate metadata before creating new measures\r\n// Initialize lists to track missing metadata\r\nvar missingFormatString = new List<string>();\r\nvar missingMeasureDescription = new List<string>();\r\nvar missingCalcItemDescription = new List<string>();\r\n\r\n// Check selected measures\r\nforeach (var m in selectedMeasures)\r\n{\r\n    if (string.IsNullOrWhiteSpace(m.FormatString))\r\n        missingFormatString.Add(m.Name);\r\n    if (string.IsNullOrWhiteSpace(m.Description))\r\n        missingMeasureDescription.Add(m.Name);\r\n}\r\n\r\n// Check selected calculation items\r\nforeach (var c in selectedCalcItems)\r\n{\r\n    if (string.IsNullOrWhiteSpace(c.Description))\r\n        missingCalcItemDescription.Add(c.Name);\r\n}\r\n\r\n// Build info message if any metadata is missing\r\nif (missingFormatString.Any() || missingMeasureDescription.Any() || missingCalcItemDescription.Any())\r\n{\r\n    string infoMessage = \"Missing metadata detected and not added to new measure:\\n\\n\" +\r\n    \"- Option 1: Press Cancel, fix items, then run script again\\n\" +\r\n    \"- Option 2: Apply format string/ description after creation\\n\";\r\n\r\n    if (missingFormatString.Any())\r\n    {\r\n        infoMessage += \"\\n• Format string missing in measures:\\n\";\r\n        foreach (var name in missingFormatString)\r\n            infoMessage += \"   - \" + name + \"\\n\";\r\n    }\r\n\r\n    if (missingMeasureDescription.Any())\r\n    {\r\n        infoMessage += \"\\n• Description missing in measures:\\n\";\r\n        foreach (var name in missingMeasureDescription)\r\n            infoMessage += \"   - \" + name + \"\\n\";\r\n    }\r\n\r\n    if (missingCalcItemDescription.Any())\r\n    {\r\n        infoMessage += \"\\n• Description missing in calculation items:\\n\";\r\n        foreach (var name in missingCalcItemDescription)\r\n            infoMessage += \"   - \" + name + \"\\n\";\r\n    }\r\n\r\n    var result = MessageBox.Show(infoMessage, \"Missing Metadata\", MessageBoxButtons.OKCancel, MessageBoxIcon.Warning);\r\n    if (result == DialogResult.Cancel)\r\n        return;\r\n}\r\n\r\n\r\n// STEP 5: Generate new measures\r\nstring calcGroupColumnName = selectedCalcGroupTable.Columns[0].DaxObjectName;\r\n\r\nforeach (var m in selectedMeasures)\r\n{\r\n    foreach (var c in selectedCalcItems)\r\n    {\r\n        // Choose format string. Sets % format for all measures with certain text included. If not the format of the measure\r\n        string formatString = \r\n            c.Name.ToLower().Contains(\"idx\") || \r\n            c.Name.Contains(\"%\") || \r\n            c.Name.ToLower().Contains(\"pct\")\r\n            ? \"#,0.0%;-#,0.0%;#,0.0%\"\r\n            : m.FormatString;\r\n\r\n // Use the DAX expression from the calculation item, replacing SELECTEDMEASURE() with the actual measure reference\r\n\r\n    string daxExpression;\r\n\r\n// Normalize the expression before replacing\r\nstring expr = c.Expression;\r\n\r\n// Replace all known casing and spacing variations\r\nexpr = expr.Replace(\"SELECTEDMEASURE()\", m.DaxObjectName);\r\nexpr = expr.Replace(\"SELECTEDMEASURE ()\", m.DaxObjectName);\r\nexpr = expr.Replace(\"SELECTEDMEASURE ( )\", m.DaxObjectName);\r\nexpr = expr.Replace(\"SELECTEDMEASURE( )\", m.DaxObjectName);\r\nexpr = expr.Replace(\"selectedmeasure()\", m.DaxObjectName);\r\nexpr = expr.Replace(\"selectedmeasure ()\", m.DaxObjectName);\r\nexpr = expr.Replace(\"selectedmeasure ( )\", m.DaxObjectName);\r\n// Add more if needed...\r\n\r\ndaxExpression = expr;\r\n\r\n        // Display folder logic\r\n        string displayFolderBase = m.DisplayFolder;\r\n        string displayFolder = displayFolderBase + \"\\\\\" + m.Name + \" - Time Intelligence\";\r\n\r\n        // Create the new measure\r\n        var newMeasure = m.Table.AddMeasure(\r\n            m.Name + \" \" + c.Name,\r\n            daxExpression,\r\n            displayFolder\r\n        );\r\n\r\n// Apply format string and description\r\nnewMeasure.FormatString = formatString;\r\n\r\n// Only add description if both components are available\r\nif (!string.IsNullOrWhiteSpace(m.Description) && !string.IsNullOrWhiteSpace(c.Description))\r\n{\r\n    newMeasure.Description = m.Description + \" - using Time Intelligence definition (\" + c.Name + \"): \" + c.Description;\r\n}\r\n    \r\n        // Format DAX for readability (skipping in TE2 due to potential slow performance\r\n        // newMeasure.Expression = FormatDax(newMeasure.Expression, shortFormat: true, skipSpaceAfterFunctionName: true);\r\n    }\r\n}\r\n\r\n//MessageBox.Show(\"New measures created successfully.\");\r\n",
      "Tooltip": "For the selected measures, it will ask for the calculation items from a selected calculation group, and then loop through all combinations, creating new measures in a folder structure",
      "ValidContexts": "Measure"
    }
  ]
}